# Вопросы к экзамену
 1. [Чем отличает БД от СУБД? Какие задачи решает СУБД? Раскройте детали каждой задачи.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#1-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82-%D0%B1%D0%B4-%D0%BE%D1%82-%D1%81%D1%83%D0%B1%D0%B4-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8-%D1%80%D0%B5%D1%88%D0%B0%D0%B5%D1%82-%D1%81%D1%83%D0%B1%D0%B4-%D1%80%D0%B0%D1%81%D0%BA%D1%80%D0%BE%D0%B9%D1%82%D0%B5-%D0%B4%D0%B5%D1%82%D0%B0%D0%BB%D0%B8-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%B9-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8)  
 2. [Проектирование БД и уровни проектирования БД.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B4-%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B8-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B1%D0%B4)
 3. [Реляционная алгебра. Реализация операций реляционной алгебры в языке SQL.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#3-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9-%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D1%8B-%D0%B2-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-sql)
 4. [Реляционная БД преимущества и недостатки.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#4-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D0%B1%D0%B4-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%B8-%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8)
 5. [Нормальные формы. Для чего нужны нормальные формы?](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#5-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B)
 6. [Нормальные формы. Приведение к 2 НФ. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#6-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-2-%D0%BD%D1%84-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 7. [Нормальные формы. Приведение к 3 НФ. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#7-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-3-%D0%BD%D1%84-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 8. [Нормальные формы. Приведение к 3 НФ Бойса — Кодда. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#8-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-3-%D0%BD%D1%84-%D0%B1%D0%BE%D0%B9%D1%81%D0%B0--%D0%BA%D0%BE%D0%B4%D0%B4%D0%B0-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 9. [Нормальные формы. Транзитивная зависимость. Функциональная зависимость. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#9-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 10. [ER-диаграмма. Для чего нужна? Составные компоненты.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#10-er-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
 11. [SQL. Типы данных. Пример применения типов данных.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#11-sql-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
 12. [SQL. DDL. Пример запроса создания таблицы. Автоинкремент vs GUID.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#12-sql-ddl-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-%D0%B0%D0%B2%D1%82%D0%BE%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-vs-guid)
 13. [SQL. DML. SELECT](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#13-sql-dml-select)
 14. [SQL. DML. INSERT, DELETE, UPDATE](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#14-sql-dml-insert-delete-update)
 15. [Индексы.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#15-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B)
 16. [Ограничения целостности](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#16-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%86%D0%B5%D0%BB%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
 17. [Транзакции. Уровни изоляции.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#17-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B8-%D0%B8%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%B8)
 18. [Хранимые процедуры и триггеры.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 19. [Масштабирование БД. Репликация.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 20. [Масштабирование БД. Шардинг.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 21. [Масштабирование БД. Партиционирование.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 22. [Оптимизация запросов.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 23. [План выполнения запроса.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 24. [OLAP и OLTP. Предназначения и отличия](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 25. [NoSQL. Виды БД и их предназначения](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#25-nosql-%D0%B2%D0%B8%D0%B4%D1%8B-%D0%B1%D0%B4-%D0%B8-%D0%B8%D1%85-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)

### 1. Чем отличает БД от СУБД? Какие задачи решает СУБД? Раскройте детали каждой задачи.
**База данных** – совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных.

**Система управления базами данных(СУБД)** – совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.

БД — это _сами данные_, а СУБД — это _программа, которая этими данными управляет_: создает, изменяет, удаляет и обеспечивает их безопасность и целостность

| Характеристика | БД (База данных) | СУБД (Система управления БД) |
|---|---|---|
| Что это | Хранилище данных | Программный комплекс |		
| Основная функция | Сохранять данные | Управлять данными и БД | 
| Пример	| Файл с таблицами	| MySQL, PostgreSQL, Oracle, MongoDB | 
| Активность	| Пассивный объект	| Активный субъект управления | 
| Может ли изменять данные самостоятельно	| Нет	| Да (через команды пользователя) | 

#### Какие задачи решает СУБД?
1) Надежное хранилище больших данных  
&nbsp; СУБД обеспечивает структурированное, долговременное и безопасное хранение больших объемов данных. Данные размещаются во внешней памяти (на дисках), а система управляет их размещением, резервным копированием, восстановлением после сбоев и журналированием изменений. Это гарантирует сохранность информации даже при аппаратных или программных сбоях  

2) Эффективный доступ  
&nbsp; СУБД оптимизирует доступ к данным с помощью индексов, кэширования, оптимизации запросов и управления буферами оперативной памяти. Это позволяет быстро выполнять сложные запросы к большим массивам данных, минимизируя задержки и обеспечивая высокую производительность работы приложений  

3) Многопользовательский доступ  
&nbsp; СУБД поддерживает одновременную работу множества пользователей с одной базой данных. Для этого реализуются механизмы управления транзакциями, блокировками и изоляцией, чтобы действия одного пользователя не мешали другим и не приводили к потере или искажению данных  

4) Разграничение прав доступа  
&nbsp; СУБД реализует системы аутентификации и авторизации, позволяя назначать различные права доступа для разных пользователей или групп. Это обеспечивает защиту данных от несанкционированного доступа и позволяет гибко управлять тем, кто и какие действия может выполнять с данными (например, только чтение, изменение, удаление)  

5) Удобная работа с данными (язык программирования для доступа к данным)  
&nbsp; СУБД предоставляет специализированные языки для работы с данными, такие как SQL для реляционных баз данных. С помощью этих языков пользователи и приложения могут создавать, изменять, удалять и искать данные, а также строить сложные аналитические запросы. Многие СУБД поддерживают расширения языков программирования для написания хранимых процедур и триггеров  

6) Обеспечение доступа (по сети)  
&nbsp; Современные СУБД позволяют получать доступ к данным по локальной сети или через интернет, что особенно важно для распределённых и облачных решений. Это реализуется через клиент-серверную архитектуру, сетевые протоколы и веб-интерфейсы, обеспечивая централизованный доступ к данным из разных точек мира и с различных устройств

### 2. Проектирование БД и уровни проектирования БД.
#### Проектирование базы данных
— создание эффективной структуры данных, обеспечивающее хранение требуемой информации  

Основные задачи проектирования:  
• Обеспечение хранения в БД всей необходимой информации  
• Обеспечение возможности получения данных по всем необходимым запросам  
• Обеспечение целостности данных (правильности их содержания): исключение противоречий в содержании данных, исключение их потери и т.д.  
• Сокращение избыточности и дублирования данных  

#### Уровни проектирования
1. [Концептуальное (инфологическое) проектирование](https://github.com/luniksss/databases/tab=readme-ov-file#%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)  
2. [Логическое (даталогическое) проектирование](https://github.com/luniksss/databases?tab=readme-ov-file#%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)  
3. [Физическое проектирование](https://github.com/luniksss/databases/tab=readme-ov-file#%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

##### Концептуальное проектирование
Концептуальное (инфологическое) проектирование — построение семантической модели предметной области, то есть информационной модели наиболее высокого уровня абстракции.  
![image](https://github.com/user-attachments/assets/dcba4468-848c-4d8a-b9b2-d3aa30eff4f2)

_Процедуры_ концептуального проектирования:  
• определение сущностей и их документирование  
• создание семантической модели предметной области  
• определение связей между сущностями и их документирование  
• обсуждение модели данных  

_Составляющие_ концептуальной модели:  
- Сущность (СОТРУДНИК)  
- Атрибут (ИМЯ)  
- Связь
 • ОДИН-К-ОДНОМУ
 • ОДИН-КО-МНОГИМ
 • МНОГИЕ-КО-МНОГИМ
 • МНОГИЕ-К-ОДНОМУ

##### Логическое проектирование
Логическое (даталогическое) проектирование — преобразование концептуальной модели на основе выбранной модели данных в логическую модель.  
Учитывается специфика конкретной модели данных, но не учитывается специфика конкретной СУБД

_Процедуры_ логического проектирования:  
- выбор модели данных
- определение набора таблиц
- нормализация таблиц(для устранения избыточности и обеспечения целостности)
- проверка логической модели данных на предмет возможности выполнения всех транзакций, предусмотренных пользователями
- определение требований поддержки целостности данных(например, обязательность заполнения, уникальность, ссылки на другие таблицы)
- создание окончательного варианта логической модели данных и обсуждение его с пользователями

**Результат**:
Логическая схема — структурированное описание таблиц, их полей, ключей и связей между ними, не зависящее от конкретной реализации.

##### Физическое проектирование
Физическое проектирование связано с конкретной СУБД и определяет, как логическая структура будет реализована на физических носителях.

_Процедуры_ физического уровня проектирования:
- выбор целевой СУБД и учет её особенностей (например, поддержка индексов, триггеров, процедур).
- определение способов хранения данных: создание индексов, партиционирование таблиц, настройка хранения больших объектов.
- оптимизация структуры таблиц и связей для повышения производительности (например, выбор типа индексов, настройка кэширования).
- разработка процедур резервного копирования, восстановления, обеспечения безопасности и управления доступом.
- настройка параметров хранения данных на физических устройствах (размещение файлов БД, журналов транзакций и т.д.).

**Результат**:
Физическая схема — описание структуры хранения данных, индексов, распределения по устройствам, настроек производительности и безопасности.

### 3. Реляционная алгебра. Реализация операций реляционной алгебры в языке SQL.
Реляционная алгебра — это формальная система операций над отношениями (таблицами), результатом которых также является отношение. 

_Основные операции:_  
- Выборка (σ):  Отбирает строки, удовлетворяющие условию(С помощью конструкции SELECT ... FROM ... WHERE ...)  
&nbsp; **Реляционная алгебра:** σ_{GroupId=101}(STUDENTS)   --- Выбирает студентов из группы 101  
&nbsp; **SQL:**  ``` SELECT * FROM STUDENTS WHERE GroupId = 101; ```
  
- Проекция (π):  Отбирает определённые столбцы, удаляя дубликаты(С помощью SELECT с указанием нужных столбцов, для удаления дубликатов — с ключевым словом DISTINCT)  
&nbsp; **Реляционная алгебра:** π_{Name}(STUDENTS)  --- Выводит имена всех студентов (без повторов)  
&nbsp; **SQL:**  ``` SELECT DISTINCT Name FROM STUDENTS; ``` 
 
- Объединение (∪):  Возвращает строки, встречающиеся хотя бы в одном из двух отношений(С помощью оператора UNION)  
&nbsp; **Реляционная алгебра:** STUDENTS1 ∪ STUDENTS2  --- Объединяет списки студентов из двух таблиц  
&nbsp; **SQL:**  ``` SELECT Name FROM STUDENTS1 UNION SELECT Name FROM STUDENTS2; ```  
  
- Пересечение (∩):  Строки, встречающиеся в обоих отношениях (С помощью оператора INTERSECT)  
&nbsp; **Реляционная алгебра:** STUDENTS1 ∩ STUDENTS2  ---  Выводит студентов, которые есть в обеих таблицах  
&nbsp; **SQL:**  ``` SELECT Name FROM STUDENTS1 INTERSECT SELECT Name FROM STUDENTS2; ```  
  
- Разность (−):  Строки, которые есть в первом отношении, но нет во втором (С помощью оператора EXCEPT (или MINUS в некоторых СУБД))  
&nbsp; **Реляционная алгебра**: STUDENTS1 − STUDENTS2 --- Выводит студентов, которые есть в первой таблице, но нет во второй  
&nbsp; **SQL:**  ``` SELECT Name FROM STUDENTS1 EXCEPT SELECT Name FROM STUDENTS2; ``` 
  
- Декартово произведение (×):  Все возможные сочетания строк двух отношений (С помощью SELECT ... FROM A, B или SELECT ... FROM A CROSS JOIN B)  
&nbsp; **Реляционная алгебра:** STUDENTS × GROUPS --- Каждый студент сочетается с каждой группой  
&nbsp; **SQL:**  ``` SELECT * FROM STUDENTS, GROUPS; ``` 
  
- Соединение (⨝):  Комбинирует строки двух отношений по условию (С помощью SELECT ... FROM A JOIN B ON ... или через WHERE при перечислении таблиц)  
&nbsp; **Реляционная алгебра:** STUDENTS ⋈_{STUDENTS.GroupId = GROUPS.GroupId} GROUPS
 --- Выводит имена студентов с названием их группы   
&nbsp; **SQL:**  ``` SELECT STUDENTS.Name, GROUPS.GroupName FROM STUDENTS JOIN GROUPS ON STUDENTS.GroupId = GROUPS.GroupId; ``` 
  
- Деление (÷):  Находит строки, связанные со всеми значениями из второго отношения (В SQL нет прямого оператора деления, но задача решается с помощью вложенных запросов с группировкой и условиями на количество совпадений)  
&nbsp; **Реляционная алгебра**: R ÷ S --- Найти студентов, которые посещают все курсы из таблицы COURSES     
&nbsp; **SQL:**  ``` SELECT StudentId
FROM Marks
WHERE CourseId IN (SELECT CourseId FROM Courses)
GROUP BY StudentId
HAVING COUNT(DISTINCT CourseId) = (SELECT COUNT(*) FROM Courses); ``` 

### 4. Реляционная БД преимущества и недостатки.
_Реляционная модель данных:_  
![image](https://github.com/user-attachments/assets/6f604a65-f117-4484-bef3-5c5f10aa0a59)  
- Ключ отношения – атрибут, или набор атрибутов, однозначно идентифицирующий объект в БД  
- Первичный ключ – ключ, используемый системой для идентификации объекта  
- Суррогатный ключ – ключ, значения которого генерируются самой системой
- Ключ-кандидат - ключ, по каким либо причинам неиспользуемый как первичный
- Составной ключ – ключ, использующий несколько атрибутов

_Реляционная база данных_ — это система хранения данных, основанная на реляционной модели, где данные представлены в виде таблиц (отношений), состоящих из строк и столбцов, а связи между таблицами задаются ключами

Особенности такой БД:  
- Данные хранятся в таблицах, состоящих из столбцов и строк;
- На пересечении каждого столбца и строчки стоит в точности одно значение;
- У каждого столбца есть своё имя, которое служит его названием, и все значения в одном столбце имеют один тип.
- Столбцы располагаются в определённом порядке, который определяется при создании таблицы, в отличие от строк, которые располагаются в произвольном порядке. В таблице может не быть ни одной строчки, но обязательно должен быть хотя бы один столбец;
- Запросы к базе данных возвращают результат в виде таблиц, которые тоже могут выступать как объект запросов.  
Примеры реляционных БД: MySQL, PostgreSQL, Microsoft Access, Microsoft SQL Server, Oracle  

**Преимущества реляционной БД:**  
1) Простота и понятность: данные организованы в виде таблиц с четкими связями, что облегчает понимание и организацию информации.  
2) Целостность данных: благодаря поддержке ACID-свойств и ограничениям (первичные ключи, внешние ключи, NOT NULL, UNIQUE) обеспечивается надежность, точность и непротиворечивость данных.  
3) Независимость данных и приложений: изменение структуры базы данных обычно не требует изменений в прикладных программах, что упрощает сопровождение и развитие систем.  
4) Гибкость и масштабируемость: таблицы можно добавлять, изменять или удалять без нарушения общей структуры, что позволяет адаптировать базу под изменяющиеся требования.  
5) Поддержка сложных запросов: реляционные БД позволяют выполнять сложные выборки, сортировки, группировки и математические операции, что важно для аналитики и отчетности.  
6) Безопасность: СУБД предоставляют детальные механизмы управления правами доступа на уровне таблиц, строк и даже ячеек.  
7) Резервное копирование и восстановление: современные СУБД обеспечивают надежные механизмы бэкапа и восстановления данных.  
8) Поддержка сообщества и стандартизация: многие реляционные СУБД имеют открытый исходный код и развитое сообщество, что способствует развитию и поддержке технологий.  

**Недостатки реляционных баз данных:**  
1) Ограниченная масштабируемость: при очень больших объемах данных и высокой нагрузке реляционные БД могут требовать дорогостоящего аппаратного обеспечения и сложной настройки.  
2) Сложность при работе со сложными связями: большое количество взаимосвязей может замедлять выполнение запросов и усложнять структуру базы.   
3) Жесткая схема: реляционная модель требует заранее определённой схемы, что может быть неудобно при работе с неструктурированными или быстро меняющимися данными.  
4) Высокие требования к ресурсам: для обеспечения ACID-свойств и целостности требуется значительная вычислительная мощность, что может снижать производительность в некоторых сценариях.
5) Несоответствие классов ПО к отношениям БД

Области применения:  
Реляционные базы данных широко используются в финансовых системах, системах управления персоналом, образовании, медицинских информационных системах, системах управления клиентскими данными и других сферах, где важна надежность, целостность и структурированность данных.

### 5. Нормальные формы. Для чего нужны нормальные формы?
_Нормальная форма_ — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения избыточных зависимостей между атрибутами.  

Нормальные формы нужны для организации структуры базы данных таким образом, чтобы минимизировать избыточность данных и избежать различных аномалий при их добавлении, обновлении и удалении.  

**Основные цели нормальных форм:**  
- Уменьшение избыточности данных, что снижает риск дублирования и противоречий в базе.
- Предотвращение аномалий модификации данных — ошибок, возникающих при изменении, удалении или добавлении информации, которые могут привести к потере или искажению данных.
- Обеспечение логической целостности и согласованности данных, что делает базу более надежной и понятной для пользователей и разработчиков.
- Создание интуитивно понятной и расширяемой структуры базы данных, которая служит хорошей основой для дальнейшего развития и поддержки.
- Упрощение применения ограничений целостности и управления связями между таблицами

  Нормализация проводится поэтапно, последовательно приводя базу данных к первой, второй, третьей и более высоким нормальным формам, каждая из которых накладывает дополнительные требования на структуру данных. Обычно достаточно нормализовать данные до третьей нормальной формы, чтобы достичь баланса между качеством данных и производительностью системы  

  **Первая нормальная форма(1NF)**  
Таблица находится в первой нормальной форме(1NF) только в том случае, когда каждая ее запись содержит только одно значение для каждого из атрибутов:
![image](https://github.com/user-attachments/assets/e2a072fb-7b71-488a-84bd-355073e02c44)

### 6. Нормальные формы. Приведение к 2 НФ. Пример.
Нормализация — это процесс организации структуры базы данных для уменьшения избыточности данных и устранения аномалий обновления, вставки и удаления. Нормальные формы — это последовательные этапы нормализации, каждая из которых предъявляет свои требования к структуре таблиц.  

Отношение находится в 1НФ, если все его атрибуты атомарны (не содержат множественных или составных значений), а все строки уникальны.
**Пример**: Таблица, где в одной ячейке не хранится список значений (например, телефоны через запятую), а для каждого значения создаётся отдельная строка.

Отношение находится во 2НФ, если оно находится в 1НФ и каждый неключевой атрибут полностью функционально зависит от всего первичного ключа, а не от его части.
**Аномалия**: Если неключевой атрибут зависит только от части составного ключа, возникают аномалии вставки, удаления и изменения данных

Например, если у нас есть таблица с курсами, годами, преподавателями и наличием экзамена, где ключ — (CourseId, Year), а атрибут Exam зависит только от CourseId, то для приведения к 2НФ мы разбиваем таблицу на две: одну с курсами, годами и преподавателями, а вторую — с курсами и экзаменами. Это устраняет аномалии вставки, удаления и изменения данных, связанные с частичными зависимостями

Студент должен привести пример отношения в 1НФ, у которого есть составной ключ и атрибуты, зависящие только от части этого ключа. Например:

| CourseId | Year | Lecturer | Exam | 
|---|---|---|---|
|1	| 2020|	Корнеев Г. А.	| yes|
|2	| 2019|	Киракозов А.Х.	| no|
|2	| 2020|	Киракозов А.Х.	| no|
|3	| 2019|	Левина А.Б.	| yes|
|3	| 2020|	Чепурной А.И.	| yes|

Здесь ключ — (CourseId, Year), но, например, Lecturer зависит только от пары (CourseId, Year), а Exam — только от CourseId.

Процесс приведения:
1) Определить функциональные зависимости.
2) Декомпозировать исходную таблицу на две:
  - Таблица 1: (CourseId, Year, Lecturer)
  - Таблица 2: (CourseId, Exam)
3) В результате каждая неключевая зависимость будет полной, и аномалии будут устранены

### 7. Нормальные формы. Приведение к 3 НФ. Пример.
Третья нормальная форма — это такая форма отношения, при которой:
- отношение находится во второй нормальной форме (2НФ);
- каждый неключевой атрибут нетранзитивно зависит от потенциального ключа, то есть не существует транзитивных зависимостей неключевых атрибутов от ключа  

В 2НФ все неключевые атрибуты полностью зависят от всего ключа. В 3НФ дополнительно требуется, чтобы **не было транзитивных зависимостей**: если A — ключ, B и C — неключевые атрибуты, и A → B, B → C, то C транзитивно зависит от A, что не допускается в 3НФ  

#### Пример и процесс приведения
Исходная таблица:
| Фамилия |	Отдел |	Телефон |
|---|---|---|
| Гришин |	1	| 11-22-33 |
| Васильев |	1	| 11-22-33 |
| Петров	| 2	| 44-55-66 |  

_Ключ_: (Фамилия)  
_Функциональные зависимости_: Фамилия → Отдел, Отдел → Телефон  
Телефон зависит от Отдела, а не напрямую от Фамилии — это _транзитивная зависимость_  

Приведение к 3НФ -- разделяем таблицу на две:
| Фамилия | Отдел |  &&  | Отдел | Телефон |  
Теперь все неключевые атрибуты зависят только от ключа своей таблицы, транзитивных зависимостей нет  

Аномалии, устраняемые 3НФ:  
- Аномалии обновления: изменение телефона отдела требует обновления во всех строках.  
- Аномалии вставки: нельзя добавить телефон нового отдела без сотрудника.  
- Аномалии удаления: удаляя последнего сотрудника отдела, теряется информация о телефоне отдела  

### 8. Нормальные формы. Приведение к 3 НФ Бойса — Кодда. Пример. 
Пусть R является переменной отношения, а X и Y — произвольными подмножествами множества атрибутов переменной отношения R. Y функционально зависимо от X тогда и только тогда, когда для любого допустимого значения переменной отношения R, если два кортежа переменной отношения R совпадают по значению X, они также совпадают и по значению Y. Подмножество X называют детерминантом, а Y — зависимой частью.  
Функциональная зависимость тривиальна тогда и только тогда, когда её правая (зависимая) часть является подмножеством её левой части (детерминанта).  
Функциональная зависимость называется неприводимой слева, если ни один атрибут не может быть опущен из её детерминанта без нарушения зависимости (иными словами, детерминант неизбыточен).  

**Нормальная форма Бойса — Кодда (BCNF)** — Переменная отношения находится в BCNF тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ (Часть составного первичного ключа не должна зависеть от неключевого столбца.)    

_Отличие BCNF от 3НФ_  
3НФ требует, чтобы неключевые атрибуты зависели только от ключа и не было транзитивных зависимостей. BCNF строже: требует, чтобы каждый определитель (левая часть любой функциональной зависимости) был потенциальным ключом. В 3НФ допускаются некоторые зависимости, если правый атрибут — часть ключа, чего не допускает BCNF  

_Пример и приведение к BCNF_  
Исходная таблица:

| Номер клиента |	Дата собеседования	| Время собеседования	| Номер комнаты	| Номер сотрудника |
|---|---|---|---|---|
| С345	| 13.10.03	| 13.00	| 103	| А138 |
| С355	| 13.10.03	| 13.05	| 103	| А136 | 
| С368	| 13.09.03	| 13.00	| 102	| А154 |
| С366	| 13.09.03	| 13.30	| 105	| А207 |  

Функциональные зависимости:  
- (Дата собеседования, Номер сотрудника) → Номер комнаты  
- (Номер клиента, Дата собеседования, Время собеседования) → Номер сотрудника  
Здесь (Дата собеседования, Номер сотрудника) — не потенциальный ключ, но определяет Номер комнаты. Это нарушает BCNF, хотя может удовлетворять 3НФ.

_Приведение к BCNF:_  
Разбиваем исходную таблицу на две:  
**Таблица 1**: Номер клиента, Дата собеседования, Время собеседования, Номер сотрудника  
**Таблица 2**: Дата собеседования, Номер сотрудника, Номер комнаты  
Теперь каждая функциональная зависимость имеет в левой части потенциальный ключ, и обе таблицы находятся в BCNF  

_Пример, где есть 3НФ, но нет BCNF_
Рассмотрим отношение R(A,B,C) с функциональными зависимостями:
AB→C  
C→B  
B→A  

**Кандидатные ключи**: AB и CB (так как по ним можно восстановить все атрибуты).  
Все атрибуты являются частью хотя бы одного кандидатного ключа (так называемые "ключевые атрибуты").  
**Проверка 3NF**: Все функциональные зависимости либо идут от ключа, либо на правой части стоят ключевые атрибуты. Например, в зависимости C→B левый атрибут не является ключом, но B — часть ключа. Следовательно, отношение находится в 3NF.  
**Проверка BCNF**: Для BCNF требуется, чтобы в любой нетривиальной функциональной зависимости левый атрибут был ключом. В зависимости C→B левый атрибут C не является ключом, поэтому отношение не находится в BCNF

### 9. Нормальные формы. Транзитивная зависимость. Функциональная зависимость. Пример.
![image](https://github.com/user-attachments/assets/7cca3f80-c734-4442-9252-cf10dba3dbbd)  
**Функциональные зависимости:**  
• Филиал компании, Должность → Зарплата  
• Должность → Наличие компьютера  
Если изменение содержимого одного столбца должно приводить к изменению другого, говорят что второй столбец функционально зависим от первого.  

**Транзитивная зависимость** — это такая зависимость, когда один атрибут зависит от другого через промежуточный атрибут:   
если A → B и B → C, то C транзитивно зависит от A (при этом B не является ключом и не зависит от C)

Транзитивные зависимости говорят о том, что в таблице хранится информация о нескольких сущностях. Это приводит к аномалиям вставки, удаления и обновления данных  

### 10. ER-диаграмма. Для чего нужна? Составные компоненты.
**ER-диаграмма** (Entity-Relationship Diagram, диаграмма "сущность-связь") — это графическое представление структуры базы данных, которое используется для моделирования и проектирования сущностей (объектов), их атрибутов и взаимосвязей между ними  
В основе ER-диаграмм лежит принцип _«рисунок нагляднее текста»_  

_Для чего нужна ER-диаграмма:_  
**1. Проектирование баз данных:** ER-диаграммы применяются на начальных этапах создания информационных систем для визуализации структуры данных, определения сущностей, их свойств и связей между ними. Это помогает создать логическую и физическую модель базы данных до её непосредственной реализации.  
**2. Оптимизация и анализ:** Используются для анализа уже существующих баз данных, выявления ошибок в логике, избыточности или недостающих элементов, а также для оптимизации структуры данных.  
**3. Улучшение коммуникации:** Служат средством согласования требований между разработчиками, аналитиками и заказчиками, упрощая обсуждение структуры данных и бизнес-правил.  

_Составные компоненты ER-диаграммы_  
- **Сущность** - это класс однотипных объектов, информация о которых должна быть учтена в модели.  
![image](https://github.com/user-attachments/assets/9f7dd5ff-6f49-4d74-a83a-5aa9b526b954)  

- **Атрибут сущности** - это именованная характеристика, являющаяся некоторым свойством сущности.  
![image](https://github.com/user-attachments/assets/a8b44662-81fc-4b8b-9b3c-cafd7f8a0c2c)

- **Ключ сущности** - это неизбыточный набор атрибутов, значения которых в совокупности являются уникальными для каждого экземпляра сущности. Неизбыточность заключается в том, что удаление любого
атрибута из ключа нарушается его уникальность.  
- **Связь** - это некоторая ассоциация между двумя сущностями. Одна сущность может быть связана с другой сущностью или сама с собою.  
  ![image](https://github.com/user-attachments/assets/b954315f-27de-4a24-9f77-8a876cabb51e)

### 11. SQL. Типы данных. Пример применения типов данных.
**SQL** - (structured query language — «язык структурированных запросов») язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных.  
Типы данных в SQL — это предопределённые категории, которые определяют, какого рода значения можно хранить в столбцах таблиц базы данных и как эти данные будут обрабатываться.  
![image](https://github.com/user-attachments/assets/85d159d2-812b-4d53-b037-6c045ab211db)  
![image](https://github.com/user-attachments/assets/f01f2132-ec88-4854-b66d-75bf909df82c)  
![image](https://github.com/user-attachments/assets/e0114d0b-9472-4596-a6f2-ea765ee5fc35)  
• ENUM (перечисление) - это столбец, который может принимать значение из списка допустимых значений, явно перечисленных в спецификации столбца в момент создания таблицы.  
• SET - это строковый тип, который может принимать ноль или более значений, каждое из которых должно быть выбрано из списка допустимых значений, определенных при создании таблицы. Элементы множества SET разделяются запятыми. Как следствие, сами элементы множества не могут содержать запятых. Например, столбец, определенный как SET("один", "два") NOT может принимать такие значения: "" "один" "два" "один, два"  

• Не используй ENUM, используй TINYINT  
• Не используй SET, используй bit flags  
• Используй VARCHAR (255) (nvarchar(4000) в T-SQL)  
• Не забывай про кодировку  
• Файлы в BLOB не храним  

![image](https://github.com/user-attachments/assets/9684442f-4352-49c1-94f6-2d040d7d7c25)  

Может быть задано значение по умолчанию, т.е. значение, которое будет подставляться в том случае, когда оператор вставки не предоставляет значения для этого столбца. Значение определяется в момент создания
атрибута, например, подстановку текущей даты или timestamp.  

NULL-значения -- Введено с целью различать в полях БД пустые (визуально не отображаемые) значения (например, строку нулевой длины) и отсутствующие значения.  
Если значение по умолчанию не задано и пользователь оставляет столбец пустым, происходит следующее:  
• если активирована поддержка значений NULL, в столбец вставляется значение NULL;  
• если поддержка значений не активирована, столбец остается пустым, но пользователь не сможет сохранить строку, пока не предоставит какое-либо значение.  

### 12. SQL. DDL. Пример запроса создания таблицы. Автоинкремент vs GUID.
**SQL** - (structured query language — «язык структурированных запросов») язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных.  
**DDL** – data definition language (язык определения данных)  
Включает всевозможные команды:  
• создания (CREATE)  
• удаления (DROP)  
• изменения структуры (ALTER)  
Объектов, таких, как:  
• таблицы (TABLE)  
• представления (VIEW)  
• триггеры (TRIGGER)  
• пользователи (USER)  

_Создание и удаление баз данных_  
`CREATE DATABASE [IF NOT EXISTS] db_name`  
`DROP DATABASE [IF EXISTS] db_name`  

```
CREATE [TEMPORARY] TABLE [IF NOT EXISTS]
tbl_name (create_definition,...)
[table_option ...]

CREATE [TEMPORARY] TABLE [IF NOT EXISTS]
tbl_name [(create_definition,...)]
[table_option ...]
select_statement

CREATE [TEMPORARY] TABLE [IF NOT EXISTS]
tbl_name
{ LIKE old_tbl_name | (LIKE old_tbl_name) }

CREATE TABLE IF NOT EXISTS `mydb`.`course` (
`id_course` INT NOT AUTO_INCREMENT,
`title` VARCHAR(245) ,
`hours` TINYINT UNSIGNED NULL,
PRIMARY KEY (`id_course`) )
ENGINE = InnoDB
```

AUTO_INCREMENT IDENTITY - Используется для генерации уникального идентификатора для новых записей БД  
![image](https://github.com/user-attachments/assets/8194535c-4574-4fc2-9112-02f9ca492cd0)  

### 13. SQL. DML. SELECT
**SQL** - (structured query language — «язык структурированных запросов») язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных.  

**DML** - (Data Manipulation Language) – работа с данными:  
- INSERT - команда добавления записей в таблицу;  
- UPDATE - команда обновления записей таблицы;  
- DELETE - команда удаления записей таблицы;  
- SELECT - команда выборки записей таблицы;  

**CRUD** (сокр. от англ. create, read, update, delete — «создать, прочесть, обновить, удалить») — акроним, обозначающий четыре базовые функции, используемые при работе с персистентными хранилищами данных.  
| Operation | SQL | HTTP |
|---|---|---|
| Create | INSERT | PUT / POST |
| Read (Retrieve) | SELECT | GET |
| Update (Modify) | UPDATE | PUT / POST / PATCH |
| Delete (Destroy) | DELETE | DELETE |

Оператор SELECT является одним из основных операторов языка SQL. Именно с его помощью происходит выборка значений, хранящихся в базе данных.  
• В структуру запроса оператора SELECT могут быть включены многие дополнительные операторы: уточняющие условие выборки, производящие группировку, сортировку выходных значений и т.д.  
• Оператор SQL SELECT имеет следующий синтаксис:
```
SELECT column_list
FROM table_name
[WHERE condition GROUP BY expression HAVING condition ORDER BY expression]
Необязательные операторы обрамлены квадратными скобками []
```

_Основные типы предикатов:_  
- **Сравнения**: =, >, <, >=, <=, <> (не равно).   
- **Логические**: AND, OR, NOT.   
- **Вхождения**: IN, NOT IN (проверяют наличие значения в списке или подзапросе).   
- **Диапазоны**: BETWEEN, NOT BETWEEN (проверяют вхождение значения в заданный диапазон).  
- **NULL**: IS NULL, IS NOT NULL (проверяют, является ли значение NULL).  
- **Сопоставление строк**: LIKE (с использованием шаблонов).  
- **Функции, возвращающие булево значение**: Некоторые функции в SQL также могут возвращать булево значение, которое может быть использовано в качестве предиката.
  
_Примеры использования предикатов:_  
` SELECT * FROM Products WHERE Price > 100;` - Выбирает все продукты, цена которых больше 100.  
`SELECT * FROM Employees WHERE Department = 'Sales' AND Salary < 50000;` - Выбирает всех сотрудников из отдела продаж с зарплатой ниже 50000.  
`SELECT * FROM Orders WHERE CustomerID IN (1, 5, 10);` - Выбирает все заказы, оформленные клиентами с ID 1, 5 или 10.  
`SELECT * FROM Products WHERE ProductName LIKE 'A%';` - Выбирает все продукты, названия которых начинаются на букву "A"  

### 14. SQL. DML. INSERT, DELETE, UPDATE


### 15. Индексы.
### 16. Ограничения целостности
### 17. Транзакции. Уровни изоляции.
### 18. Хранимые процедуры и триггеры.
### 19. Масштабирование БД. Репликация.
### 20. Масштабирование БД. Шардинг.
### 21. Масштабирование БД. Партиционирование.
### 22. Оптимизация запросов.
### 23. План выполнения запроса.
### 24. OLAP и OLTP. Предназначения и отличия.
### 25. NoSQL. Виды БД и их предназначения.
