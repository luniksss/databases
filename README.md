# Вопросы к экзамену
 1. [Чем отличает БД от СУБД? Какие задачи решает СУБД? Раскройте детали каждой задачи.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#1-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82-%D0%B1%D0%B4-%D0%BE%D1%82-%D1%81%D1%83%D0%B1%D0%B4-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8-%D1%80%D0%B5%D1%88%D0%B0%D0%B5%D1%82-%D1%81%D1%83%D0%B1%D0%B4-%D1%80%D0%B0%D1%81%D0%BA%D1%80%D0%BE%D0%B9%D1%82%D0%B5-%D0%B4%D0%B5%D1%82%D0%B0%D0%BB%D0%B8-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%B9-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8)  
 2. [Проектирование БД и уровни проектирования БД.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#2-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B4-%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B8-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B1%D0%B4)
 3. [Реляционная алгебра. Реализация операций реляционной алгебры в языке SQL.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#3-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9-%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D1%8B-%D0%B2-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-sql)
 4. [Реляционная БД преимущества и недостатки.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#4-%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D0%B1%D0%B4-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%B8-%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8)
 5. [Нормальные формы. Для чего нужны нормальные формы?](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#5-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B)
 6. [Нормальные формы. Приведение к 2 НФ. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#6-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-2-%D0%BD%D1%84-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 7. [Нормальные формы. Приведение к 3 НФ. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#7-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-3-%D0%BD%D1%84-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 8. [Нормальные формы. Приведение к 3 НФ Бойса — Кодда. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#8-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-3-%D0%BD%D1%84-%D0%B1%D0%BE%D0%B9%D1%81%D0%B0--%D0%BA%D0%BE%D0%B4%D0%B4%D0%B0-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 9. [Нормальные формы. Транзитивная зависимость. Функциональная зависимость. Пример.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#9-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D0%BE%D1%80%D0%BC%D1%8B-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
 10. [ER-диаграмма. Для чего нужна? Составные компоненты.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#10-er-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B)
 11. [SQL. Типы данных. Пример применения типов данных.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#11-sql-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
 12. [SQL. DDL. Пример запроса создания таблицы. Автоинкремент vs GUID.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#12-sql-ddl-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-%D0%B0%D0%B2%D1%82%D0%BE%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-vs-guid)
 13. [SQL. DML. SELECT](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#13-sql-dml-select)
 14. [SQL. DML. INSERT, DELETE, UPDATE](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#14-sql-dml-insert-delete-update)
 15. [Индексы.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#15-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B)
 16. [Ограничения целостности](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#16-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%86%D0%B5%D0%BB%D0%BE%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
 17. [Транзакции. Уровни изоляции.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#17-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B8-%D0%B8%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%B8)
 18. [Хранимые процедуры и триггеры.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#18-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BC%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-%D0%B8-%D1%82%D1%80%D0%B8%D0%B3%D0%B3%D0%B5%D1%80%D1%8B)
 19. [Масштабирование БД. Репликация.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#19-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B4-%D1%80%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F)
 20. [Масштабирование БД. Шардинг.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#20-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B4-%D1%88%D0%B0%D1%80%D0%B4%D0%B8%D0%BD%D0%B3).  
 21. [Масштабирование БД. Партиционирование.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#21-%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B1%D0%B4-%D0%BF%D0%B0%D1%80%D1%82%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
 22. [Оптимизация запросов.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#22-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2)
 23. [План выполнения запроса.](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#23-%D0%BF%D0%BB%D0%B0%D0%BD-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0)
 24. [OLAP и OLTP. Предназначения и отличия](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#24-olap-%D0%B8-oltp-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
 25. [NoSQL. Виды БД и их предназначения](https://github.com/luniksss/databases/tree/main?tab=readme-ov-file#25-nosql-%D0%B2%D0%B8%D0%B4%D1%8B-%D0%B1%D0%B4-%D0%B8-%D0%B8%D1%85-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)

### 1. Чем отличает БД от СУБД? Какие задачи решает СУБД? Раскройте детали каждой задачи.
**База данных** – совокупность данных, хранимых в соответствии со схемой данных, манипулирование которыми выполняют в соответствии с правилами средств моделирования данных.

**Система управления базами данных(СУБД)** – совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.

БД — это _сами данные_, а СУБД — это _программа, которая этими данными управляет_: создает, изменяет, удаляет и обеспечивает их безопасность и целостность

| Характеристика | БД (База данных) | СУБД (Система управления БД) |
|---|---|---|
| Что это | Хранилище данных | Программный комплекс |		
| Основная функция | Сохранять данные | Управлять данными и БД | 
| Пример	| Файл с таблицами	| MySQL, PostgreSQL, Oracle, MongoDB | 
| Активность	| Пассивный объект	| Активный субъект управления | 
| Может ли изменять данные самостоятельно	| Нет	| Да (через команды пользователя) | 

#### Какие задачи решает СУБД?
1) Надежное хранилище больших данных  
&nbsp; СУБД обеспечивает структурированное, долговременное и безопасное хранение больших объемов данных. Данные размещаются во внешней памяти (на дисках), а система управляет их размещением, резервным копированием, восстановлением после сбоев и журналированием изменений. Это гарантирует сохранность информации даже при аппаратных или программных сбоях  

2) Эффективный доступ  
&nbsp; СУБД оптимизирует доступ к данным с помощью индексов, кэширования, оптимизации запросов и управления буферами оперативной памяти. Это позволяет быстро выполнять сложные запросы к большим массивам данных, минимизируя задержки и обеспечивая высокую производительность работы приложений  

3) Многопользовательский доступ  
&nbsp; СУБД поддерживает одновременную работу множества пользователей с одной базой данных. Для этого реализуются механизмы управления транзакциями, блокировками и изоляцией, чтобы действия одного пользователя не мешали другим и не приводили к потере или искажению данных  

4) Разграничение прав доступа  
&nbsp; СУБД реализует системы аутентификации и авторизации, позволяя назначать различные права доступа для разных пользователей или групп. Это обеспечивает защиту данных от несанкционированного доступа и позволяет гибко управлять тем, кто и какие действия может выполнять с данными (например, только чтение, изменение, удаление)  

5) Удобная работа с данными (язык программирования для доступа к данным)  
&nbsp; СУБД предоставляет специализированные языки для работы с данными, такие как SQL для реляционных баз данных. С помощью этих языков пользователи и приложения могут создавать, изменять, удалять и искать данные, а также строить сложные аналитические запросы. Многие СУБД поддерживают расширения языков программирования для написания хранимых процедур и триггеров  

6) Обеспечение доступа (по сети)  
&nbsp; Современные СУБД позволяют получать доступ к данным по локальной сети или через интернет, что особенно важно для распределённых и облачных решений. Это реализуется через клиент-серверную архитектуру, сетевые протоколы и веб-интерфейсы, обеспечивая централизованный доступ к данным из разных точек мира и с различных устройств

### 2. Проектирование БД и уровни проектирования БД.
#### Проектирование базы данных
— создание эффективной структуры данных, обеспечивающее хранение требуемой информации  

Основные задачи проектирования:  
• Обеспечение хранения в БД всей необходимой информации  
• Обеспечение возможности получения данных по всем необходимым запросам  
• Обеспечение целостности данных (правильности их содержания): исключение противоречий в содержании данных, исключение их потери и т.д.  
• Сокращение избыточности и дублирования данных  

#### Уровни проектирования
1. [Концептуальное (инфологическое) проектирование](https://github.com/luniksss/databases/tab=readme-ov-file#%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)  
2. [Логическое (даталогическое) проектирование](https://github.com/luniksss/databases?tab=readme-ov-file#%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)  
3. [Физическое проектирование](https://github.com/luniksss/databases/tab=readme-ov-file#%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

##### Концептуальное проектирование
Концептуальное (инфологическое) проектирование — построение семантической модели предметной области, то есть информационной модели наиболее высокого уровня абстракции.  
![image](https://github.com/user-attachments/assets/dcba4468-848c-4d8a-b9b2-d3aa30eff4f2)

_Процедуры_ концептуального проектирования:  
• определение сущностей и их документирование  
• создание семантической модели предметной области  
• определение связей между сущностями и их документирование  
• обсуждение модели данных  

_Составляющие_ концептуальной модели:  
- Сущность (СОТРУДНИК)  
- Атрибут (ИМЯ)  
- Связь
 • ОДИН-К-ОДНОМУ
 • ОДИН-КО-МНОГИМ
 • МНОГИЕ-КО-МНОГИМ
 • МНОГИЕ-К-ОДНОМУ

##### Логическое проектирование
Логическое (даталогическое) проектирование — преобразование концептуальной модели на основе выбранной модели данных в логическую модель.  
Учитывается специфика конкретной модели данных, но не учитывается специфика конкретной СУБД

_Процедуры_ логического проектирования:  
- выбор модели данных
- определение набора таблиц
- нормализация таблиц(для устранения избыточности и обеспечения целостности)
- проверка логической модели данных на предмет возможности выполнения всех транзакций, предусмотренных пользователями
- определение требований поддержки целостности данных(например, обязательность заполнения, уникальность, ссылки на другие таблицы)
- создание окончательного варианта логической модели данных и обсуждение его с пользователями

**Результат**:
Логическая схема — структурированное описание таблиц, их полей, ключей и связей между ними, не зависящее от конкретной реализации.

##### Физическое проектирование
Физическое проектирование связано с конкретной СУБД и определяет, как логическая структура будет реализована на физических носителях.

_Процедуры_ физического уровня проектирования:
- выбор целевой СУБД и учет её особенностей (например, поддержка индексов, триггеров, процедур).
- определение способов хранения данных: создание индексов, партиционирование таблиц, настройка хранения больших объектов.
- оптимизация структуры таблиц и связей для повышения производительности (например, выбор типа индексов, настройка кэширования).
- разработка процедур резервного копирования, восстановления, обеспечения безопасности и управления доступом.
- настройка параметров хранения данных на физических устройствах (размещение файлов БД, журналов транзакций и т.д.).

**Результат**:
Физическая схема — описание структуры хранения данных, индексов, распределения по устройствам, настроек производительности и безопасности.

### 3. Реляционная алгебра. Реализация операций реляционной алгебры в языке SQL.
Реляционная алгебра — это формальная система операций над отношениями (таблицами), результатом которых также является отношение. 

_Основные операции:_  
- Выборка (σ):  Отбирает строки, удовлетворяющие условию(С помощью конструкции SELECT ... FROM ... WHERE ...)  
&nbsp; **Реляционная алгебра:** σ_{GroupId=101}(STUDENTS)   --- Выбирает студентов из группы 101  
&nbsp; **SQL:**  ``` SELECT * FROM STUDENTS WHERE GroupId = 101; ```
  
- Проекция (π):  Отбирает определённые столбцы, удаляя дубликаты(С помощью SELECT с указанием нужных столбцов, для удаления дубликатов — с ключевым словом DISTINCT)  
&nbsp; **Реляционная алгебра:** π_{Name}(STUDENTS)  --- Выводит имена всех студентов (без повторов)  
&nbsp; **SQL:**  ``` SELECT DISTINCT Name FROM STUDENTS; ``` 
 
- Объединение (∪):  Возвращает строки, встречающиеся хотя бы в одном из двух отношений(С помощью оператора UNION)  
&nbsp; **Реляционная алгебра:** STUDENTS1 ∪ STUDENTS2  --- Объединяет списки студентов из двух таблиц  
&nbsp; **SQL:**  ``` SELECT Name FROM STUDENTS1 UNION SELECT Name FROM STUDENTS2; ```  
  
- Пересечение (∩):  Строки, встречающиеся в обоих отношениях (С помощью оператора INTERSECT)  
&nbsp; **Реляционная алгебра:** STUDENTS1 ∩ STUDENTS2  ---  Выводит студентов, которые есть в обеих таблицах  
&nbsp; **SQL:**  ``` SELECT Name FROM STUDENTS1 INTERSECT SELECT Name FROM STUDENTS2; ```  
  
- Разность (−):  Строки, которые есть в первом отношении, но нет во втором (С помощью оператора EXCEPT (или MINUS в некоторых СУБД))  
&nbsp; **Реляционная алгебра**: STUDENTS1 − STUDENTS2 --- Выводит студентов, которые есть в первой таблице, но нет во второй  
&nbsp; **SQL:**  ``` SELECT Name FROM STUDENTS1 EXCEPT SELECT Name FROM STUDENTS2; ``` 
  
- Декартово произведение (×):  Все возможные сочетания строк двух отношений (С помощью SELECT ... FROM A, B или SELECT ... FROM A CROSS JOIN B)  
&nbsp; **Реляционная алгебра:** STUDENTS × GROUPS --- Каждый студент сочетается с каждой группой  
&nbsp; **SQL:**  ``` SELECT * FROM STUDENTS, GROUPS; ``` 
  
- Соединение (⨝):  Комбинирует строки двух отношений по условию (С помощью SELECT ... FROM A JOIN B ON ... или через WHERE при перечислении таблиц)  
&nbsp; **Реляционная алгебра:** STUDENTS ⋈_{STUDENTS.GroupId = GROUPS.GroupId} GROUPS
 --- Выводит имена студентов с названием их группы   
&nbsp; **SQL:**  ``` SELECT STUDENTS.Name, GROUPS.GroupName FROM STUDENTS JOIN GROUPS ON STUDENTS.GroupId = GROUPS.GroupId; ``` 
  
- Деление (÷):  Находит строки, связанные со всеми значениями из второго отношения (В SQL нет прямого оператора деления, но задача решается с помощью вложенных запросов с группировкой и условиями на количество совпадений)  
&nbsp; **Реляционная алгебра**: R ÷ S --- Найти студентов, которые посещают все курсы из таблицы COURSES     
&nbsp; **SQL:**  ``` SELECT StudentId
FROM Marks
WHERE CourseId IN (SELECT CourseId FROM Courses)
GROUP BY StudentId
HAVING COUNT(DISTINCT CourseId) = (SELECT COUNT(*) FROM Courses); ``` 

### 4. Реляционная БД преимущества и недостатки.
_Реляционная модель данных:_  
![image](https://github.com/user-attachments/assets/6f604a65-f117-4484-bef3-5c5f10aa0a59)  
- Ключ отношения – атрибут, или набор атрибутов, однозначно идентифицирующий объект в БД  
- Первичный ключ – ключ, используемый системой для идентификации объекта  
- Суррогатный ключ – ключ, значения которого генерируются самой системой
- Ключ-кандидат - ключ, по каким либо причинам неиспользуемый как первичный
- Составной ключ – ключ, использующий несколько атрибутов

_Реляционная база данных_ — это система хранения данных, основанная на реляционной модели, где данные представлены в виде таблиц (отношений), состоящих из строк и столбцов, а связи между таблицами задаются ключами

Особенности такой БД:  
- Данные хранятся в таблицах, состоящих из столбцов и строк;
- На пересечении каждого столбца и строчки стоит в точности одно значение;
- У каждого столбца есть своё имя, которое служит его названием, и все значения в одном столбце имеют один тип.
- Столбцы располагаются в определённом порядке, который определяется при создании таблицы, в отличие от строк, которые располагаются в произвольном порядке. В таблице может не быть ни одной строчки, но обязательно должен быть хотя бы один столбец;
- Запросы к базе данных возвращают результат в виде таблиц, которые тоже могут выступать как объект запросов.  
Примеры реляционных БД: MySQL, PostgreSQL, Microsoft Access, Microsoft SQL Server, Oracle  

**Преимущества реляционной БД:**  
1) Простота и понятность: данные организованы в виде таблиц с четкими связями, что облегчает понимание и организацию информации.  
2) Целостность данных: благодаря поддержке ACID-свойств и ограничениям (первичные ключи, внешние ключи, NOT NULL, UNIQUE) обеспечивается надежность, точность и непротиворечивость данных.  
3) Независимость данных и приложений: изменение структуры базы данных обычно не требует изменений в прикладных программах, что упрощает сопровождение и развитие систем.  
4) Гибкость и масштабируемость: таблицы можно добавлять, изменять или удалять без нарушения общей структуры, что позволяет адаптировать базу под изменяющиеся требования.  
5) Поддержка сложных запросов: реляционные БД позволяют выполнять сложные выборки, сортировки, группировки и математические операции, что важно для аналитики и отчетности.  
6) Безопасность: СУБД предоставляют детальные механизмы управления правами доступа на уровне таблиц, строк и даже ячеек.  
7) Резервное копирование и восстановление: современные СУБД обеспечивают надежные механизмы бэкапа и восстановления данных.  
8) Поддержка сообщества и стандартизация: многие реляционные СУБД имеют открытый исходный код и развитое сообщество, что способствует развитию и поддержке технологий.  

**Недостатки реляционных баз данных:**  
1) Ограниченная масштабируемость: при очень больших объемах данных и высокой нагрузке реляционные БД могут требовать дорогостоящего аппаратного обеспечения и сложной настройки.  
2) Сложность при работе со сложными связями: большое количество взаимосвязей может замедлять выполнение запросов и усложнять структуру базы.   
3) Жесткая схема: реляционная модель требует заранее определённой схемы, что может быть неудобно при работе с неструктурированными или быстро меняющимися данными.  
4) Высокие требования к ресурсам: для обеспечения ACID-свойств и целостности требуется значительная вычислительная мощность, что может снижать производительность в некоторых сценариях.
5) Несоответствие классов ПО к отношениям БД

Области применения:  
Реляционные базы данных широко используются в финансовых системах, системах управления персоналом, образовании, медицинских информационных системах, системах управления клиентскими данными и других сферах, где важна надежность, целостность и структурированность данных.

### 5. Нормальные формы. Для чего нужны нормальные формы?
_Нормальная форма_ — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения избыточных зависимостей между атрибутами.  

Нормальные формы нужны для организации структуры базы данных таким образом, чтобы минимизировать избыточность данных и избежать различных аномалий при их добавлении, обновлении и удалении.  

**Основные цели нормальных форм:**  
- Уменьшение избыточности данных, что снижает риск дублирования и противоречий в базе.
- Предотвращение аномалий модификации данных — ошибок, возникающих при изменении, удалении или добавлении информации, которые могут привести к потере или искажению данных.
- Обеспечение логической целостности и согласованности данных, что делает базу более надежной и понятной для пользователей и разработчиков.
- Создание интуитивно понятной и расширяемой структуры базы данных, которая служит хорошей основой для дальнейшего развития и поддержки.
- Упрощение применения ограничений целостности и управления связями между таблицами

  Нормализация проводится поэтапно, последовательно приводя базу данных к первой, второй, третьей и более высоким нормальным формам, каждая из которых накладывает дополнительные требования на структуру данных. Обычно достаточно нормализовать данные до третьей нормальной формы, чтобы достичь баланса между качеством данных и производительностью системы  

  **Первая нормальная форма(1NF)**  
Таблица находится в первой нормальной форме(1NF) только в том случае, когда каждая ее запись содержит только одно значение для каждого из атрибутов:
![image](https://github.com/user-attachments/assets/e2a072fb-7b71-488a-84bd-355073e02c44)

### 6. Нормальные формы. Приведение к 2 НФ. Пример.
Нормализация — это процесс организации структуры базы данных для уменьшения избыточности данных и устранения аномалий обновления, вставки и удаления. Нормальные формы — это последовательные этапы нормализации, каждая из которых предъявляет свои требования к структуре таблиц.  

Отношение находится в 1НФ, если все его атрибуты атомарны (не содержат множественных или составных значений), а все строки уникальны.
**Пример**: Таблица, где в одной ячейке не хранится список значений (например, телефоны через запятую), а для каждого значения создаётся отдельная строка.

Отношение находится во 2НФ, если оно находится в 1НФ и каждый неключевой атрибут полностью функционально зависит от всего первичного ключа, а не от его части.
**Аномалия**: Если неключевой атрибут зависит только от части составного ключа, возникают аномалии вставки, удаления и изменения данных

Например, если у нас есть таблица с курсами, годами, преподавателями и наличием экзамена, где ключ — (CourseId, Year), а атрибут Exam зависит только от CourseId, то для приведения к 2НФ мы разбиваем таблицу на две: одну с курсами, годами и преподавателями, а вторую — с курсами и экзаменами. Это устраняет аномалии вставки, удаления и изменения данных, связанные с частичными зависимостями

Студент должен привести пример отношения в 1НФ, у которого есть составной ключ и атрибуты, зависящие только от части этого ключа. Например:

| CourseId | Year | Lecturer | Exam | 
|---|---|---|---|
|1	| 2020|	Корнеев Г. А.	| yes|
|2	| 2019|	Киракозов А.Х.	| no|
|2	| 2020|	Киракозов А.Х.	| no|
|3	| 2019|	Левина А.Б.	| yes|
|3	| 2020|	Чепурной А.И.	| yes|

Здесь ключ — (CourseId, Year), но, например, Lecturer зависит только от пары (CourseId, Year), а Exam — только от CourseId.

Процесс приведения:
1) Определить функциональные зависимости.
2) Декомпозировать исходную таблицу на две:
  - Таблица 1: (CourseId, Year, Lecturer)
  - Таблица 2: (CourseId, Exam)
3) В результате каждая неключевая зависимость будет полной, и аномалии будут устранены

### 7. Нормальные формы. Приведение к 3 НФ. Пример.
Третья нормальная форма — это такая форма отношения, при которой:
- отношение находится во второй нормальной форме (2НФ);
- каждый неключевой атрибут нетранзитивно зависит от потенциального ключа, то есть не существует транзитивных зависимостей неключевых атрибутов от ключа  

В 2НФ все неключевые атрибуты полностью зависят от всего ключа. В 3НФ дополнительно требуется, чтобы **не было транзитивных зависимостей**: если A — ключ, B и C — неключевые атрибуты, и A → B, B → C, то C транзитивно зависит от A, что не допускается в 3НФ  

#### Пример и процесс приведения
Исходная таблица:
| Фамилия |	Отдел |	Телефон |
|---|---|---|
| Гришин |	1	| 11-22-33 |
| Васильев |	1	| 11-22-33 |
| Петров	| 2	| 44-55-66 |  

_Ключ_: (Фамилия)  
_Функциональные зависимости_: Фамилия → Отдел, Отдел → Телефон  
Телефон зависит от Отдела, а не напрямую от Фамилии — это _транзитивная зависимость_  

Приведение к 3НФ -- разделяем таблицу на две:
| Фамилия | Отдел |  &&  | Отдел | Телефон |  
Теперь все неключевые атрибуты зависят только от ключа своей таблицы, транзитивных зависимостей нет  

Аномалии, устраняемые 3НФ:  
- Аномалии обновления: изменение телефона отдела требует обновления во всех строках.  
- Аномалии вставки: нельзя добавить телефон нового отдела без сотрудника.  
- Аномалии удаления: удаляя последнего сотрудника отдела, теряется информация о телефоне отдела  

### 8. Нормальные формы. Приведение к 3 НФ Бойса — Кодда. Пример. 
Пусть R является переменной отношения, а X и Y — произвольными подмножествами множества атрибутов переменной отношения R. Y функционально зависимо от X тогда и только тогда, когда для любого допустимого значения переменной отношения R, если два кортежа переменной отношения R совпадают по значению X, они также совпадают и по значению Y. Подмножество X называют детерминантом, а Y — зависимой частью.  
Функциональная зависимость тривиальна тогда и только тогда, когда её правая (зависимая) часть является подмножеством её левой части (детерминанта).  
Функциональная зависимость называется неприводимой слева, если ни один атрибут не может быть опущен из её детерминанта без нарушения зависимости (иными словами, детерминант неизбыточен).  

**Нормальная форма Бойса — Кодда (BCNF)** — Переменная отношения находится в BCNF тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ (Часть составного первичного ключа не должна зависеть от неключевого столбца.)    

_Отличие BCNF от 3НФ_  
3НФ требует, чтобы неключевые атрибуты зависели только от ключа и не было транзитивных зависимостей. BCNF строже: требует, чтобы каждый определитель (левая часть любой функциональной зависимости) был потенциальным ключом. В 3НФ допускаются некоторые зависимости, если правый атрибут — часть ключа, чего не допускает BCNF  

_Пример и приведение к BCNF_  
Исходная таблица:

| Номер клиента |	Дата собеседования	| Время собеседования	| Номер комнаты	| Номер сотрудника |
|---|---|---|---|---|
| С345	| 13.10.03	| 13.00	| 103	| А138 |
| С355	| 13.10.03	| 13.05	| 103	| А136 | 
| С368	| 13.09.03	| 13.00	| 102	| А154 |
| С366	| 13.09.03	| 13.30	| 105	| А207 |  

Функциональные зависимости:  
- (Дата собеседования, Номер сотрудника) → Номер комнаты  
- (Номер клиента, Дата собеседования, Время собеседования) → Номер сотрудника  
Здесь (Дата собеседования, Номер сотрудника) — не потенциальный ключ, но определяет Номер комнаты. Это нарушает BCNF, хотя может удовлетворять 3НФ.

_Приведение к BCNF:_  
Разбиваем исходную таблицу на две:  
**Таблица 1**: Номер клиента, Дата собеседования, Время собеседования, Номер сотрудника  
**Таблица 2**: Дата собеседования, Номер сотрудника, Номер комнаты  
Теперь каждая функциональная зависимость имеет в левой части потенциальный ключ, и обе таблицы находятся в BCNF  

_Пример, где есть 3НФ, но нет BCNF_
Рассмотрим отношение R(A,B,C) с функциональными зависимостями:
AB→C  
C→B  
B→A  

**Кандидатные ключи**: AB и CB (так как по ним можно восстановить все атрибуты).  
Все атрибуты являются частью хотя бы одного кандидатного ключа (так называемые "ключевые атрибуты").  
**Проверка 3NF**: Все функциональные зависимости либо идут от ключа, либо на правой части стоят ключевые атрибуты. Например, в зависимости C→B левый атрибут не является ключом, но B — часть ключа. Следовательно, отношение находится в 3NF.  
**Проверка BCNF**: Для BCNF требуется, чтобы в любой нетривиальной функциональной зависимости левый атрибут был ключом. В зависимости C→B левый атрибут C не является ключом, поэтому отношение не находится в BCNF

### 9. Нормальные формы. Транзитивная зависимость. Функциональная зависимость. Пример.
![image](https://github.com/user-attachments/assets/7cca3f80-c734-4442-9252-cf10dba3dbbd)  
**Функциональные зависимости:**  
• Филиал компании, Должность → Зарплата  
• Должность → Наличие компьютера  
Если изменение содержимого одного столбца должно приводить к изменению другого, говорят что второй столбец функционально зависим от первого.  

**Транзитивная зависимость** — это такая зависимость, когда один атрибут зависит от другого через промежуточный атрибут:   
если A → B и B → C, то C транзитивно зависит от A (при этом B не является ключом и не зависит от C)

Транзитивные зависимости говорят о том, что в таблице хранится информация о нескольких сущностях. Это приводит к аномалиям вставки, удаления и обновления данных  

### 10. ER-диаграмма. Для чего нужна? Составные компоненты.
**ER-диаграмма** (Entity-Relationship Diagram, диаграмма "сущность-связь") — это графическое представление структуры базы данных, которое используется для моделирования и проектирования сущностей (объектов), их атрибутов и взаимосвязей между ними  
В основе ER-диаграмм лежит принцип _«рисунок нагляднее текста»_  

_Для чего нужна ER-диаграмма:_  
**1. Проектирование баз данных:** ER-диаграммы применяются на начальных этапах создания информационных систем для визуализации структуры данных, определения сущностей, их свойств и связей между ними. Это помогает создать логическую и физическую модель базы данных до её непосредственной реализации.  
**2. Оптимизация и анализ:** Используются для анализа уже существующих баз данных, выявления ошибок в логике, избыточности или недостающих элементов, а также для оптимизации структуры данных.  
**3. Улучшение коммуникации:** Служат средством согласования требований между разработчиками, аналитиками и заказчиками, упрощая обсуждение структуры данных и бизнес-правил.  

_Составные компоненты ER-диаграммы_  
- **Сущность** - это класс однотипных объектов, информация о которых должна быть учтена в модели.  
![image](https://github.com/user-attachments/assets/9f7dd5ff-6f49-4d74-a83a-5aa9b526b954)  

- **Атрибут сущности** - это именованная характеристика, являющаяся некоторым свойством сущности.  
![image](https://github.com/user-attachments/assets/a8b44662-81fc-4b8b-9b3c-cafd7f8a0c2c)

- **Ключ сущности** - это неизбыточный набор атрибутов, значения которых в совокупности являются уникальными для каждого экземпляра сущности. Неизбыточность заключается в том, что удаление любого
атрибута из ключа нарушается его уникальность.  
- **Связь** - это некоторая ассоциация между двумя сущностями. Одна сущность может быть связана с другой сущностью или сама с собою.  
  ![image](https://github.com/user-attachments/assets/b954315f-27de-4a24-9f77-8a876cabb51e)

### 11. SQL. Типы данных. Пример применения типов данных.
**SQL** - (structured query language — «язык структурированных запросов») язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных.  
Типы данных в SQL — это предопределённые категории, которые определяют, какого рода значения можно хранить в столбцах таблиц базы данных и как эти данные будут обрабатываться.  
![image](https://github.com/user-attachments/assets/85d159d2-812b-4d53-b037-6c045ab211db)  
![image](https://github.com/user-attachments/assets/f01f2132-ec88-4854-b66d-75bf909df82c)  
![image](https://github.com/user-attachments/assets/e0114d0b-9472-4596-a6f2-ea765ee5fc35)  
• ENUM (перечисление) - это столбец, который может принимать значение из списка допустимых значений, явно перечисленных в спецификации столбца в момент создания таблицы.  
• SET - это строковый тип, который может принимать ноль или более значений, каждое из которых должно быть выбрано из списка допустимых значений, определенных при создании таблицы. Элементы множества SET разделяются запятыми. Как следствие, сами элементы множества не могут содержать запятых. Например, столбец, определенный как SET("один", "два") NOT может принимать такие значения: "" "один" "два" "один, два"  

• Не используй ENUM, используй TINYINT  
• Не используй SET, используй bit flags  
• Используй VARCHAR (255) (nvarchar(4000) в T-SQL)  
• Не забывай про кодировку  
• Файлы в BLOB не храним  

![image](https://github.com/user-attachments/assets/9684442f-4352-49c1-94f6-2d040d7d7c25)  

Может быть задано значение по умолчанию, т.е. значение, которое будет подставляться в том случае, когда оператор вставки не предоставляет значения для этого столбца. Значение определяется в момент создания
атрибута, например, подстановку текущей даты или timestamp.  

NULL-значения -- Введено с целью различать в полях БД пустые (визуально не отображаемые) значения (например, строку нулевой длины) и отсутствующие значения.  
Если значение по умолчанию не задано и пользователь оставляет столбец пустым, происходит следующее:  
• если активирована поддержка значений NULL, в столбец вставляется значение NULL;  
• если поддержка значений не активирована, столбец остается пустым, но пользователь не сможет сохранить строку, пока не предоставит какое-либо значение.  

### 12. SQL. DDL. Пример запроса создания таблицы. Автоинкремент vs GUID.
**SQL** - (structured query language — «язык структурированных запросов») язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных.  
**DDL** – data definition language (язык определения данных)  
Включает всевозможные команды:  
• создания (CREATE)  
• удаления (DROP)  
• изменения структуры (ALTER)  
Объектов, таких, как:  
• таблицы (TABLE)  
• представления (VIEW)  
• триггеры (TRIGGER)  
• пользователи (USER)  

_Создание и удаление баз данных_  
`CREATE DATABASE [IF NOT EXISTS] db_name`  
`DROP DATABASE [IF EXISTS] db_name`  

```
CREATE [TEMPORARY] TABLE [IF NOT EXISTS]
tbl_name (create_definition,...)
[table_option ...]

CREATE [TEMPORARY] TABLE [IF NOT EXISTS]
tbl_name [(create_definition,...)]
[table_option ...]
select_statement

CREATE [TEMPORARY] TABLE [IF NOT EXISTS]
tbl_name
{ LIKE old_tbl_name | (LIKE old_tbl_name) }

CREATE TABLE IF NOT EXISTS `mydb`.`course` (
`id_course` INT NOT AUTO_INCREMENT,
`title` VARCHAR(245) ,
`hours` TINYINT UNSIGNED NULL,
PRIMARY KEY (`id_course`) )
ENGINE = InnoDB
```

AUTO_INCREMENT IDENTITY - Используется для генерации уникального идентификатора для новых записей БД  
![image](https://github.com/user-attachments/assets/8194535c-4574-4fc2-9112-02f9ca492cd0)  

### 13. SQL. DML. SELECT
**SQL** - (structured query language — «язык структурированных запросов») язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных.  

**DML** - (Data Manipulation Language) – работа с данными:  
- INSERT - команда добавления записей в таблицу;  
- UPDATE - команда обновления записей таблицы;  
- DELETE - команда удаления записей таблицы;  
- SELECT - команда выборки записей таблицы;  

**CRUD** (сокр. от англ. create, read, update, delete — «создать, прочесть, обновить, удалить») — акроним, обозначающий четыре базовые функции, используемые при работе с персистентными хранилищами данных.  
| Operation | SQL | HTTP |
|---|---|---|
| Create | INSERT | PUT / POST |
| Read (Retrieve) | SELECT | GET |
| Update (Modify) | UPDATE | PUT / POST / PATCH |
| Delete (Destroy) | DELETE | DELETE |

Оператор SELECT является одним из основных операторов языка SQL. Именно с его помощью происходит выборка значений, хранящихся в базе данных.  
• В структуру запроса оператора SELECT могут быть включены многие дополнительные операторы: уточняющие условие выборки, производящие группировку, сортировку выходных значений и т.д.  
• Оператор SQL SELECT имеет следующий синтаксис:
```
SELECT column_list
FROM table_name
[WHERE condition GROUP BY expression HAVING condition ORDER BY expression]
Необязательные операторы обрамлены квадратными скобками []
```

_Основные типы предикатов:_  
- **Сравнения**: =, >, <, >=, <=, <> (не равно).   
- **Логические**: AND, OR, NOT.   
- **Вхождения**: IN, NOT IN (проверяют наличие значения в списке или подзапросе).   
- **Диапазоны**: BETWEEN, NOT BETWEEN (проверяют вхождение значения в заданный диапазон).  
- **NULL**: IS NULL, IS NOT NULL (проверяют, является ли значение NULL).  
- **Сопоставление строк**: LIKE (с использованием шаблонов).  
- **Функции, возвращающие булево значение**: Некоторые функции в SQL также могут возвращать булево значение, которое может быть использовано в качестве предиката.
  
_Примеры использования предикатов:_  
` SELECT * FROM Products WHERE Price > 100;` - Выбирает все продукты, цена которых больше 100.  
`SELECT * FROM Employees WHERE Department = 'Sales' AND Salary < 50000;` - Выбирает всех сотрудников из отдела продаж с зарплатой ниже 50000.  
`SELECT * FROM Orders WHERE CustomerID IN (1, 5, 10);` - Выбирает все заказы, оформленные клиентами с ID 1, 5 или 10.  
`SELECT * FROM Products WHERE ProductName LIKE 'A%';` - Выбирает все продукты, названия которых начинаются на букву "A"  

### 14. SQL. DML. INSERT, DELETE, UPDATE
**SQL** - (structured query language — «язык структурированных запросов») язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных.  

**DML** - (Data Manipulation Language) – работа с данными:  
- INSERT - команда добавления записей в таблицу;  
- UPDATE - команда обновления записей таблицы;  
- DELETE - команда удаления записей таблицы;  
- SELECT - команда выборки записей таблицы;

#### Оператор INSERT
Оператор INSERT позволяет вносить изменения в структуру таблиц: добавлять записи (строки) и заполнять их значениями и имеет следующий синтаксис:  
`INSERT INTO table__name ([column__name, ... ]) VALUES (expressions, ...)`  

Так же, значения могут быть записаны и без указания столбцов:  
`INSERT INTO table__name VALUES (expressions, ...)`  

Запись значений может производиться и с помощью оператора SELECT:  
`INSERT INTO table_name SELECT column_name, ... FROM table__name`  

#### Оператор UPDATE
Оператор UPDATE используется для изменения значений в записях таблицы и имеет следующий синтаксис:  
`UPDATE table_name SET expression [WHERE condition]`  

#### Оператор DELETE
Оператор DELETE используется для удаления записей таблиц. Если предложение WHERE отсутствует, удаляются все строки из таблицы:  
`DELETE FROM <имя таблицы> [WHERE <предикат>];`  
Оператор TRUNCATE используется для очистки таблицы:  
`TRUNCATE TABLE <имя таблицы>`  

### 15. Индексы.
**Индекс** — это специальная структура данных, создаваемая для одного или нескольких столбцов таблицы с целью ускорения поиска, сортировки и фильтрации данных. Индекс позволяет находить строки, удовлетворяющие критерию поиска, значительно быстрее, чем при последовательном просмотре всей таблицы.  

В базе данных индекс обычно реализуется в виде структуры B-дерева или его вариаций, где хранятся значения индексируемых столбцов и указатели на соответствующие строки таблицы. При поиске по индексируемому столбцу СУБД сначала обращается к индексу, быстро находит нужное значение и сразу получает ссылку на строку в таблице, минуя полное сканирование таблицы  

_Типы индексов по структуре_
1) B-дерево - структура данных, дерево поиска. С точки зрения внешнего логического представления, сбалансированное, сильно ветвистое дерево. Часто используется для хранения данных во внешней памяти.  
2) Хеш-таблица - структура данных, реализующая интерфейс ассоциативного массива, она позволяет хранить пары (ключ, значение).  

**Кластеризованный индекс** — индекс, при котором значения индекса хранятся вместе с данными, им соответствующими. Существует только один кластеризованный индекс для каждой таблицы, так как строки данных могут храниться в единственном порядке. Если у таблицы нет кластерного индекса, таблица является кучей. Записи не имеют определенного порядка хранения.  

**Некластеризованный индекес** - В отличие от кластеризованного индекса, листья некластеризованного индекса содержат столбцы, по которым определен данный индекс, и указатель на строки с реальными данными в таблице.  

**Составной индекс** — это индекс, построенный по нескольким колонкам. Такие индексы имеет смысл использовать, когда в одном запросе фигурируют более одной колонки. Все работает точно так же, как и для обычного
индекса. Но для значений используются значений всех входящих колонок сразу. Очередность колонок в индексе важна.  

**Уникальный индекс** - индекс для колонок, значения в которых должны быть уникальными по всей таблице. При поиске данных, SQL остановится после обнаружения первого соответствия. В случае обычного индекса будет
обязательно проведена еще одна проверка (следующего значения в индексе).  

**Покрывающий индекс** - индекс, который позволяет конкретному запросу сразу получить все необходимые данные с листьев индекса без дополнительных обращений к записям самой таблицы.  

**Полнотекстовый индекс** - В отличие от оператора LIKE, такой тип поиска предусматривает создание соответствующего полнотекстового индекса, который представляет собой своеобразный словарь упоминаний слов в полях.  
Поисковые характеристики полнотекстового индекса:  
• Одно или несколько конкретных слов или фраз (простое выражение)  
• Слова, начинающиеся заданным текстом, или фразы с такими словами (префиксные выражения)  
• Словоформы конкретного слова (производное выражение)  
• Слова или фразы, находящиеся рядом с другими словами или фразами (выражения с учетом расположения)
• Синонимические формы конкретного слова (тезаурус)  
• Слова или фразы со взвешенными значениями (взвешенное выражение)  

| Тип индекса |	Описание |
|---|---|
| Обычный (неуникальный) |	Ускоряет поиск, но допускает повторяющиеся значения в столбце |
| Уникальный |	Запрещает дублирование значений в индексируемом столбце, реализует ограничение уникальности |
| Кластеризованный |	Определяет физический порядок хранения строк в таблице по значению индексируемого столбца |
| Составной |	Создаётся по нескольким столбцам; ускоряет запросы, где участвуют все или часть этих столбцов |
| Полнотекстовый, по выражению	| Используется для поиска по тексту или по вычисляемым значениям в столбцах|

_Преимущества_:  
- Значительно ускоряют выборку данных и выполнение запросов с условиями поиска, сортировки и соединения.  
- Могут реализовывать ограничения уникальности.

_Недостатки_:  
- Занимают дополнительное место на диске.  
- Замедляют операции вставки, обновления и удаления, так как индекс нужно обновлять при изменении данных
- Для одной таблицы в запросе может быть использован только один индекс  

_Именование индексов_  
Именование индексов таблицы должно подчиняться следующим правилам:  
1) «Имя индекса» = «Префикс индекса» + «__» + наименование таблицы + «_» + перечисление имен столбцов таблицы, участвующих в построении индекса, разделенных символом “-”.  
2) «Префик индекса» может принимать одно из следующих значений:  
• IX = обычный индекс;  
• IU = уникальный индекс.  
`CREATE NONCLUSTERED INDEX [IX_issuance_id_copy] ON [dbo].[issuance] [id_copy] ASC`

-- Создание обычного индекса  
`CREATE INDEX idx_lastname ON employees(last_name);`  

-- Создание уникального индекса  
`CREATE UNIQUE INDEX idx_email ON users(email);`  

-- Создание составного индекса  
`CREATE INDEX idx_name_dob ON students(last_name, birth_date);`

### 16. Ограничения целостности
Це́лостность ба́зы да́нных (англ. database integrity) — соответствие имеющейся в базе данных информации её внутренней логике, структуре и всем явно заданным правилам. Каждое правило, налагающее некоторое ограничение на возможное состояние базы данных, называется ограничением целостности.  

_Примеры правил_:  
- вес детали должен быть положительным;
- количество знаков в телефонном номере не должно превышать 15;
- возраст родителей не может быть меньше возраста их биологического ребёнка и так далее.  

_В теории реляционных баз данных принято выделять четыре типа ограничений целостности:_
1) Ограничением базы данных называется ограничение на значения, которые разрешено принимать указанной базе данных.  
2) Ограничением переменной отношения называется ограничение на значения, которые разрешено принимать указанной переменной отношения.  
3) Ограничением атрибута называется ограничение на значения, которые разрешено принимать указанному атрибуту.  
4) Ограничение типа представляет собой ни что иное, как определение множества значений, из которых состоит данный тип.

Простыми словами:  
1) Ограничение на значение столбцов
2) Ссылочная целостность
3) Доменная целостность
4) Целостность сущностей  
![image](https://github.com/user-attachments/assets/a1170ee7-140a-4adf-9fae-4defbff99249)  

_Ограничение на значение столбцов_  
**Первичный ключ (primary key)**  
Используется для обеспечения уникальности данных в столбцах и, в основном, для обеспечения ссылок на другие таблицы посредством связывания их внешними ключами.  

**Внешний ключ (foreign key)**  
Применяется вместе с определённым раннее первичным ключом или же ограничением уникальности (unique) в связанной таблице. Условие на значение внешнего ключа одной таблицы ставит в соответствие один или несколько столбцов другой таблицы.  

**Ограничение уникальности (unique)**  
Назначается чтобы запретить повторение значений в столбце таблицы. Для столбца, на котором определено ограничение первичного ключа, не может быть определено ограничение уникальности, так как уникальный индекс данного столбца уже создан.  

**Проверочное ограничение (check)**  
Устанавливает, какие значения может хранить столбец. Это ограничение, например, можно использовать для столбца, хранящего номера квартир в многоквартирном доме.  

_Ссылочная целостность_  
Ссылочная целостность обеспечивается системой первичных и внешних ключей. Этими средствами можно гарантировать, что у нас не будет ссылок на несуществующие объекты таблицы.  

_Доменная целостность_  
Отвечает за то, чтобы в соответствующих полях базы данных были соответствующие значения. Например, номер телефона, как правило, обозначается цифрами, а имя или фамилия — буквами. В базах данных такая целостность зачастую обеспечивается запретом пустых значений (NOT NULL), триггерами, ключами а так же хранимыми процедурами.  

_Целостность сущностей_  
Заключается в том, что любое отношение должно обладать первичным ключом или проверкой уникальности. Иными словами, главная задача целостности сущностей — сделать так, чтобы данные об одном объекте (сущности) не попали в базу данных дважды, так как при несоблюдении данного ограничения в базе данных может храниться противоречивая информация об одном объекте. Поддержание целостности сущностей осуществляется системой управления базой данных (СУБД).  

```
CREATE TABLE employees (  
    employee_id INT PRIMARY KEY,           -- целостность сущностей  
    department_id INT REFERENCES departments(department_id), -- ссылочная целостность  
    email VARCHAR(100) UNIQUE,             -- уникальность  
    salary DECIMAL(10,2) CHECK (salary > 0), -- пользовательское ограничение  
    birth_date DATE NOT NULL               -- доменная целостность (отсутствие NULL)  
);  
```

### 17. Транзакции. Уровни изоляции. 
**Транзакция** – последовательность операций с данными, выполняющаяся как единое целое.  
Если СУБД может выполнить всю группу запросов, она делает это, но если любой из запросов не может быть выполнен в результате сбоя или по какой-то другой причине, не будет выполнен ни один запрос группы.  

_Свойства транзакции - ACID:_  
• Atomicity - Атомарность   
• Consistency - Согласованность  
• Isolation - Изоляция  
• Durability - Долговечность  

1) **Атомарность**:  
Транзакция должна функционировать как единая неделимая единица работы таким образом, чтобы вся транзакция была либо выполнена, либо отменена. Когда транзакции являются атомарными, не существует такого понятия, как частично выполненная транзакция: все или ничего.

2) **Согласованость(консистентность)**: 
База данных должна всегда переходить из одного непротиворечивого состояния в последующее.  
Из примера: непротиворечивость гарантирует, что сбой не приведет к исчезновению $200 со счета. Поскольку транзакция не будет зафиксирована, ни одно из изменений в этой транзакции не будет отражено в базе данных.  
3) **Изолированность**:  
Результаты транзакции невидимы другим транзакциям, пока она не закончена.  
В примере: гарантирует, что если программа суммирования остатков на банковских счетах будет запущена, она по-прежнему увидит $200 на текущем счете.  

4) **Долговечность**:  
Будучи зафиксированы, внесенные в ходе транзакции изменения становятся постоянными. Изменения должны быть записаны так, чтобы данные не могли быть потеряны в случае сбоя системы.

_Уровни изоляции_  
Набор правил, устанавливающих, какие изменения видны внутри и вне транзакции, а какие нет.  
`SET TRANSACTION ISOLATION LEVEL <название>;`  

![image](https://github.com/user-attachments/assets/62c94335-1c81-45bf-a9e4-2c2db47cff64)  

1) **READ UNCOMMITED**  
Пользователи могут считывать строки, которые были изменены другими транзакциями, но еще не были зафиксированы. Данный уровень изоляции называется “Грязное чтение” - Dirty read  
`SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED`  

2) **READ COMMITTED**  
На этом уровне транзакция может читать только те изменения в других параллельных транзакциях, которые уже были закоммичены. Это нас спасает от грязного чтения, но не спасает от неповторяющегося чтения и от фантомного чтения  
• Транзакция увидит только те изменения, которые были уже зафиксированы другими транзакциями к моменту ее начала  
• Изменения останутся невидимыми для других транзакций, пока текущая транзакция не будет зафиксирована  
• Возможно невоспроизводимое чтение:  
![image](https://github.com/user-attachments/assets/8b44b485-25dc-4625-a081-7d280848337a)  

2) **REPEATABLE READ**  
Любые строки, которые считываются в контексте транзакции будут «выглядеть такими же» при последовательных операциях чтения в пределах одной и той же транзакции  
![image](https://github.com/user-attachments/assets/44183ee2-a55d-4bdf-bb08-3181bbb15ed8)

3) **SERIALIZABLE**  
• Полная блокировка строк/таблиц, которые использует транзакция  
• Одновременно с одними и теми же данными может работать только одна транзакция

![image](https://github.com/user-attachments/assets/1957557f-0f31-4cd8-9807-6a4418daaed4)  
![image](https://github.com/user-attachments/assets/4f328d33-d479-46d6-b95c-4818fcba0f09)  

_Журнал транзакций_  
Общий алгоритм:  
• изменения пишутся в журнал транзакций (состояние до и после) и изменяются страницы БД в памяти;  
• в журнал транзакций сбрасывается маркер успешного завершения транзакции;  
• журнал транзакций сбрасывается на диск;  
• данные из журнала транзакций применяются к таблицам БД.  
! Минимальное время транзакции не меньше времени сброса данных на диск.  

_Взаимоблокировки (deadlock)_  
Две или более транзакции запрашивают блокировку одних и тех же ресурсов, в результате чего образуется циклическая зависимость  
```
-- Транзакция #1  
BEGIN TRANSACTION  
UPDATE account SET balance = 45 WHERE id = 1;  
UPDATE account SET balance = 19 WHERE id = 2;  
COMMIT;  
-- Транзакция #2  
BEGIN TRANSACTION  
UPDATE account SET balance = 20 WHERE id = 2;  
UPDATE account SET balance = 47 WHERE id = 1;  
COMMIT;  
```

_Борьба с блокировками_  
1) Укорачивать транзакции  
2) Понижать режим изоляции  
3) Запускать изоляции в одном направлении  
4) SET DEADLOCK PRIORITY

### 18. Хранимые процедуры и триггеры.
#### **Хранимая процедура**  
– объект базы данных, представляющий собой набор SQL-инструкций, в которых можно объявлять переменные, управлять потоками данных, а также применять другие техники программирования.  
```
-- создание процедуры  
CREATE PROCEDURE reader_procedure AS SELECT * FROM reader GO

-- вызов процедуры  
EXECUTE reader_procedure

-- удаление процедуры  
IF OBJECT_ID('reader_procedure','P') IS NOT DROP PROC reader_procedure GO  
```

_Плюсы процедур_:  
• Повторное использование кода. Обеспечивает связность доступа к данным и управления ими между различными приложениями.  
• Изоляция пользователей от таблиц базы данных. Позволяет давать доступ к хранимым процедурам, но не к самим данным таблиц.  
• Сокращения сетевого трафика. С помощью хранимых процедур множество запросов могут быть объединены.  
• Повышенная производительность. При первом запуске хранимой процедуры она компилируется и в дальнейшем её обработка осуществляется быстрее.  

_Минусы процедур:_  
• Повышение нагрузки на сервер баз данных в связи с тем, что большая часть работы выполняется на серверной части, а меньшая - на клиентской.  
• Распределение логики приложения в нескольких местах: программный код и код хранимых процедур, тем самым усложняя процесс понимания манипулирования данными.  
• Миграция с одной СУБД на другую может привести к проблемам.  

_Создание хранимых процедур MySQL_  
```
DELIMITER //  
CREATE PROCEDURE `hello_world` ()  
LANGUAGE SQL  
DETERMINISTIC  
SQL SECURITY DEFINER  
COMMENT 'A procedure'  
BEGIN  
SELECT 'Hello World !';  
END//  
DELIMITER ;  
```

• **Language:** в целях обеспечения переносимости, по умолчанию указан SQL.  
• **Deterministic**: если процедура все время возвращает один и тот же результат, и принимает одни и те же входящие параметры. Значение по умолчанию - NOT DETERMINISTIC.
• **SQL Security:** проверка прав пользователя. INVOKER – это пользователь, вызывающий хранимую процедуру. DEFINER - это “создатель” процедуры. Значение по умолчанию - DEFINER.  

_Возврат данных из хранимой процедуры_  
• Результирующий набор - Возврат значений через инструкцию SELECT  
```
-- создание процедуры  
CREATE PROCEDURE reader_procedure AS SELECT * FROM reader GO

-- вызов процедуры  
EXECUTE reader_procedure  
```
• Выходной параметр - Возврат значений через OUTPUT параметр  
```
-- создание процедуры  
CREATE PROCEDURE count_readers

-- входной параметр  
@cnt INT OUTPUT AS SELECT @cnt = COUNT(*) FROM reader GO

-- объявляем переменную  
DECLARE @cnt INT;

-- вызов процедуры  
EXECUTE count_readers @cnt = @cnt OUTPUT

-- выводим количество записей   
SELECT @cnt AS total_readers  
```
• Код возврата - Процедура может возвращать целочисленное значение, называемое кодом возврата, чтобы указать состояние выполнения процедуры  
```
-- создание процедуры  
CREATE PROCEDURE return_code AS RETURN (0) GO

-- объявляем переменную  
DECLARE @cnt INT;

-- вызов процедуры  
EXECUTE @cnt = return_code

-- выводим количество записей  
SELECT @cnt AS return_code  
```

#### **Триггер** 
это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено определенной модификацией данных в заданной таблице или столбце реляционной базы данных.  

Запускаются сервером при наступлении определенного события:  
• Вставка записи в таблицу  
• Обновление записи в таблице  
• Удаление записи из таблицы  

Формальное определение триггера:  
```
CREATE TRIGGER имя_триггера  
ON {имя_таблицы | имя_представления}  
{AFTER | INSTEAD OF} [INSERT | UPDATE | DELETE ]  
AS выражения_sql  
```

_Применение триггера_  
• Триггеры применяются для проверки правил предметной области и для обеспечения целостности данных  
• Триггеры применяются при денормализации с целью поддержания актуальности данных;  
• Накопление аудиторской информации посредством фиксации сведений о внесенных изменениях и тех лицах, которые их выполнили  

_Особенности применения триггеров_  
• Не активируются при каскадных изменениях по внешним ключам.  
• Триггер запускается сервером автоматически при попытке изменения данных в таблице, с которой он связан.  
• Все производимые им модификации данных рассматриваются как одна транзакция. В случае обнаружения ошибки или нарушения целостности данных происходит откат этой транзакции.  

```
CREATE TRIGGER issuance_check  
ON issuance  
AFTER INSERT, UPDATE  
AS  
  IF (ROWCOUNT_BIG() = 0)  
  RETURN;  
  -- проверяем существование невалидных записей  
  IF EXISTS (SELECT * FROM issuance WHERE issue_date > deadline_date)  
  BEGIN  
  -- кидаем ошибку и откатываем изменения  
  RAISERROR ('issue_date could not be greater then deadline_date', 16, 1);  
  ROLLBACK TRANSACTION;  
  RETURN  
  END;  
GO  
```

### 19. Масштабирование БД. Репликация.
**Масштабирование** — это процесс изменения размера системы  
**Масштабируемость** — это свойство системы, сохраняя пропускную способность, справляться с увеличением нагрузки при увеличении определенных ресурсов системы  

_Необходимость в масштабировании_:  
• Ограничение пропускной способности чтения данных  
• Ограничение пропускной способности записи данных  

_Виды масштабирования систем_  
• Вертикальное масштабирование – увеличение производительности узла  
• Горизонтальное масштабирование – увеличение количества узлов  

_Вертикальное масштабирование_  
• Увеличение объема оперативной памяти  
• Наращивание мощности процессора  
• Усиление дисковой подсистемы  
Масштабируемость в этом контексте означает возможность заменять в существующей вычислительной системе компоненты более мощными и быстрыми. Самый простой способ масштабирования, так как не требует никаких изменений в прикладных программах.  

_Горизонтальное масштабирование_  
Горизонтальное масштабирование — разбиение системы на более мелкие структурные компоненты и разнесение их по отдельным физическим машинам. Масштабируемость в этом контексте означает возможность добавлять к системе новые узлы, серверы, процессоры для увеличения общей производительности.

_Горизонтальное масштабирование БД_  
• Репликация  
• Секционирование  
• Шардинг  

**Репликация**  
Репликация — механизм синхронизации содержимого нескольких копий объекта (например, содержимого базы данных).
Наращиваемое решение. Если одного сервера не хватает — ставится второй, третий и т.д.  

_Когда использовать?_  
1) Распространение данных  
Репликация позволяет создать копию базы данных у географически удаленном пункте, например в другом центре обработки данных.
2) Балансировка нагрузки
С помощью репликации можно распределить запросы на чтение между несколькими серверами. В приложениях с интенсивным чтением эта тактика работает очень хорошо. Реализовать несложное балансирование нагрузки можно, внеся совсем немного изменений в код.
3) Резервное копирование  
4) Аварийное переключение на резервный сервер (failover)  
5) Тестирование новых версий СУБД

_Роли серверов в репликации_  
• **Мастер сервер** - основной сервер базы данных. На нем происходят все изменения в данных (любые запросы MySQL INSERT/UPDATE/DELETE).  
• **Слейв сервер** – сервер, который постоянно копирует все изменения с Мастера.  

_Виды репликации_  
1) **Master-slave репликация**: основной сервер БД доступен на чтение и запись, реплика доступна для чтения либо недоступна вообще. Данные на мастере и реплике идентичны. Все запросы на изменение базы направляются мастер серверу, тогда как запросы на чтение распределяются между слейвами.  
**Недостаток**: При выходе из строя мастер сервера, все запросы на модификацию и добавление данных не будут выполняться.  
3) **Master-master репликация:** все сервера являются доступными для записи, а измененные данные распространяются на весь кластер.
   a) Цепочка мастер серверов
     Очень удобна для географического распределения данных. Например, ставим сервера в Европе, Азии и Америке, настраиваем их в цепочку и учим приложение выбирать сервер в зависимости от региона. Таким образом получаем выигрыш за счет  уменьшения пути путешествия запроса к серверу.  
  **Недостаток**:  
  - Сложность реализации.
  - Не многие СУБД поддерживают такую схему.
  - Нужно продумывать обработку конфликтов
  b) 2 мастера, много слейвов  
   Схема является цепочкой из двух мастер серверов. Оба мастера выполняют запросы на модификацию данных и имеют равное количество слейвов. Таким образом при выходе из строя одного мастера, приложение продолжит работать со вторым и его слейвами.

_Гарантии репликации_
1) Синхронная  
Мастер-сервер не подтверждает транзакцию до того, как реплика не подтвердит получение данных.
Синхронная репликация – при изменении состояния одной реплики все остальные должны быть обновлены в одной и той же транзакции. Все операции чтения можно всегда отправлять на слейв. Однако это может значительно уменьшить скорость работы СУБД.  
2) Асинхронная  
Мастер-сервер не ждёт подтвержения получения данных от реплики.
Асинхронная репликация – при изменении состояния одной реплики все остальные обновляются спустя некоторое время, т.е. асинхронная репликация не гарантирует, что на всех репликах в одно и то же время содержатся одинаковые данные, доступные для чтения Так как мастер не ждет обновления слейва, то запросы на изменения выполняются быстрее. Варианты реализации:  

**Физическая**  
Передаётся информация о физическом изменении страниц базы данных.  
Общий принцип:  
• Главный сервер записывает изменения данных в журнал транзакций;  
• Подчиненный сервер копирует события журнала транзакций;  
• Подчиненный сервер воспроизводит изменения из журнала транзакций.  
Плюсы:  
• Простота и надёжность;  
• Подчиненный сервер в точности соответствует мастер-серверу;  
• Практически отсутствуют накладные расходы.  
Минусы:  
• Если данные на мастере были испорчены из-за сбоев RAM, то на подчинённом сервере так же будут испорченные данные;  
• На реплике не может быть локальных изменений схемы данных;  
• Не возможна мастер-мастер репликация;  

**Логическая**  
Передаётся информация об изменении записей базы данных.  
Общий принцип:  
• Мастер сервер записывает изменения данных в журнал транзакций;  
• На базе журнала транзакций мастер сервер восстанавливает информация об изменении записей;  
• Данные об изменении записей передаются на подчиненный сервер.  
Плюсы:  
• Более компактный обмен данными;  
• Если данные на мастере были испорчены из-за сбоев RAM, то репликация остановится;  
• На мастере и подчинённом сервере можно использовать разную схему данных;  
Минусы:  
• Более высокая нагрузка на подчинённый сервер;  
• Нет хорошего решения проблемы репликации DDL-запросов.  

3) Majority  
Мастер-сервер ждёт подтвержения получения данных от N-реплик.

4) Семисинхронная (MySQL)  
Мастер-сервер не подтверждает транзакцию до того, как "живые" реплики не подтвердят получение данных.

**_Преимущества и недостатки_**  
+ Решает проблему нагрузки.  
+ Имеем копию нашей БД  
- При большом количестве слейвов усложняется схема распространения изменений, которая в дальнейшем становится узким местом.  
- Усложнение программной архитектуры – например, чтение данных с слейва, до которого не докатились изменения.  

### 20. Масштабирование БД. Шардинг.  
**Масштабирование** — это процесс изменения размера системы  
**Масштабируемость** — это свойство системы, сохраняя пропускную способность, справляться с увеличением нагрузки при увеличении определенных ресурсов системы  

_Необходимость в масштабировании_:  
• Ограничение пропускной способности чтения данных  
• Ограничение пропускной способности записи данных  

_Виды масштабирования систем_  
• Вертикальное масштабирование – увеличение производительности узла  
• Горизонтальное масштабирование – увеличение количества узлов  

_Вертикальное масштабирование_  
• Увеличение объема оперативной памяти  
• Наращивание мощности процессора  
• Усиление дисковой подсистемы  
Масштабируемость в этом контексте означает возможность заменять в существующей вычислительной системе компоненты более мощными и быстрыми. Самый простой способ масштабирования, так как не требует никаких изменений в прикладных программах.  

_Горизонтальное масштабирование_  
Горизонтальное масштабирование — разбиение системы на более мелкие структурные компоненты и разнесение их по отдельным физическим машинам. Масштабируемость в этом контексте означает возможность добавлять к системе новые узлы, серверы, процессоры для увеличения общей производительности.

_Горизонтальное масштабирование БД_  
• Репликация  
• Секционирование  
• Шардинг  

**Секционирование**  
Секционирование (partitioning) - это разбиение больших таблиц на логические части по выбранным критериям.  
Позволяет:  
• Отделить статические данные от изменяющихся  
• Воспользоваться физической близостью взаимосвязанных данных для оптимизации запросов  
• Проектировать таблицы так, чтобы запрос обращался к возможно меньшему объему данных  
• Упростить обслуживание очень больших наборов данных  
• Размещать партиции на разных физических дисках  
• Редко используемые архивные данные можно разместить на медленном хранилище  
• Уменьшить размер индексов  

_Варианты секционирования_    
• По диапазону значений  
• По точному списку значений  
• По HASH функции  
• По ключу  

_Пример секционирования_  
```
-- создание функции секционирования  
CREATE PARTITION FUNCTION part_func (int) AS RANGE LEFT FOR VALUES (100, 200, 300);  
-- мапинг файловых групп к функции  
CREATE PARTITION SCHEME part_sch_test AS PARTITION part_func TO (fg1, fg2, fg3, fg_default);  
-- создание секционированной таблицы  
CREATE TABLE [dbo].[issuance](  
    [id_issuance] [int] IDENTITY(1,1) NOT NULL,  
    [id_copy] [int] NOT NULL, [id_reader] [int] NOT NULL,  
    [issue_date] [date] NOT NULL, [release_date] [date] NOT NULL,  
    [deadline_date] [date] NOT NULL,  
    CONSTRAINT [PK_issuance] PRIMARY KEY CLUSTERED  
    (  
        [id_issuance] ASC  
    )  
) ON part_func ([id_reader])  
```

_Секционирование по дате(или id)_  
**Достоинства**:  
• легко понять;  
• количество строк в данной таблице будет достаточно стабильным;(в случае id - 100%)  
**Недостатки**:  
• требует поддержки – время от времени нам придётся добавлять новые партиции;  
• поиск по имени пользователя или id потребует сканирования всех партиций;  

_По первой букве имени_  
**Достоинства**:  
• легко понять;  
• никакой поддержки – есть строго определенный набор партиций и нам никогда не придется добавлять новые;  
**Недостатки**:  
• количество строк в партициях будет стабильно расти;  
• в некоторых партициях будет существенно больше строк, чем в других (больше людей с никами, начинающимися на “t*", чем на “y*");  
• поиск по id потребует сканирования всех партиций;  

По хэшу имени пользователя  
**Достоинства**:  
• никакой поддержки – есть строго определенный набор партиций и нам никогда не придется добавлять новые;  
• строки будут равно распределяться между партициями;  
**Недостатки**:  
• количество строк в партициях будет стабильно расти;  
• поиск по id потребует сканирования всех партиций;  
• поиск по имени пользователя будет сканировать только одну партицию, но только при использовании дополнительных условий.  

_Файлы и файловые группы_  
 Файловые группы позволяют распределить хранение таблиц/баз данных по разным физическим дискам. Применяется с целью избежать ограничений скорости хранилища данных.  

### 21. Масштабирование БД. Партиционирование.  
**Масштабирование** — это процесс изменения размера системы  
**Масштабируемость** — это свойство системы, сохраняя пропускную способность, справляться с увеличением нагрузки при увеличении определенных ресурсов системы  

_Необходимость в масштабировании_:  
• Ограничение пропускной способности чтения данных  
• Ограничение пропускной способности записи данных  

_Виды масштабирования систем_  
• Вертикальное масштабирование – увеличение производительности узла  
• Горизонтальное масштабирование – увеличение количества узлов  

_Вертикальное масштабирование_  
• Увеличение объема оперативной памяти  
• Наращивание мощности процессора  
• Усиление дисковой подсистемы  
Масштабируемость в этом контексте означает возможность заменять в существующей вычислительной системе компоненты более мощными и быстрыми. Самый простой способ масштабирования, так как не требует никаких изменений в прикладных программах.  

_Горизонтальное масштабирование_  
Горизонтальное масштабирование — разбиение системы на более мелкие структурные компоненты и разнесение их по отдельным физическим машинам. Масштабируемость в этом контексте означает возможность добавлять к системе новые узлы, серверы, процессоры для увеличения общей производительности.

_Горизонтальное масштабирование БД_  
• Репликация  
• Секционирование  
• Шардинг  

_Шардинг_  
Шардинг – это разделение данных на уровне ресурсов, в результате которого данные размещаются на различных серверах исходя из требований к нагрузке.  

**Вертикальный шардинг**  
Вертикальный шардинг — это выделение таблицы или группы таблиц на отдельный сервер. Например, в приложении есть такие таблицы:  
• user — данные пользователей  
• photo — фотографии пользователей  
• album — альбомы пользователей  
Таблицу user Вы оставляете на одном сервере, а таблицы photo и album переносите на другой. В таком случае в приложении Вам необходимо будет использовать соответствующее соединение для работы с каждой таблицей.  

**Горизонтальный шардинг**  
Горизонтальный шардинг — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц, которые не умещаются на одном сервере. Разделение таблицы на куски делается по такому принципу:  
• На нескольких серверах создается одна и та же таблица (только структура, без данных).  
• В приложении выбирается условие, по которому будет определяться нужное соединение (например, четные на один сервер, а нечетные — на другой).  
• Перед каждым обращением к таблице происходит выбор нужного соединения.  

_Критерии шардинга_  
Какой-то параметр, который позволит определять, на каком именно сервере лежат те или иные данные.  
1) ID поля таблицы
2) Хеш-таблица с соответствиями «пользователь=сервер» (Тогда, при определении сервера, нужно будет выбрать сервер из этой таблицы. В этом случае узкое место — это большая таблица соответсвия, которую нужно хранить в одном месте.)
3) Определять имя сервера с помощью числового (буквенного) преобразования.  
(Например, можно вычислять номер сервера, как остаток от деления на определенное число (количество серверов, между которыми Вы делите таблицу). В этом случае узкое место — это проблема добавления новых серверов — Вам придется делать перераспределение данных между новым количеством серверов.)

_Преимущества шардинга_  
• Единственный способ добиться увеличения пропускной способности записи  
• Масштабирование используя десятки, сотни и тысячи узлов баз данных, построенных на недорогом оборудовании вместо использования дорогих и высокопроизводительных серверов  
• Достижение нужной производительности путем увеличения количества узлов  
• Построение относительно дешевых решений с большим объемом данных  
• При полном выходе из строя одного шарда безвозвратно потеряется только часть данных  

_Проблемы шардинга_  
• Поддержка ссылочной целостности  
• Объединения таблиц между шардами  
• Генерация эффективного идентификатора для шардинга  
• Определение, в какой шард попадают данные  
• Перераспределение шардов  
• Сортировка и агрегация данных между шардами  
• Управление соединениями  

### 22. Оптимизация запросов.
_Оптимизация запроса_  
• **Изменение порядка соединения** - Таблицы не обязательно соединять именно в том порядке, который указан в запросе.  
• **Применение алгебраических правил эквивалентности:**  
```
(5=5 AND a>5) -> a>5  
(a < b AND b=c) AND a=5 -> b>5 AND b=c AND a=5  
```
• **Оптимизации COUNT(), MIN() и MAX()** - Наличие индексов и сведений о возможности хранения NULL-значений в столбцах часто позволяет вообще не вычислять эти выражения.  
• **Покрывающие индексы** - Если индекс содержит все необходимые запросу столбцы, то СУБД может воспользоваться им, вообще не читая данные таблицы.  
• **Оптимизация подзапросов** - СУБД умеет преобразовывать некоторые виды подзапросов в более эффективные эквивалентные формы, сводя их к поиску по индексу.  
• **Раннее завершение** - СУБД может прекратить обработку запроса (или какой-то шаг обработки), как только поймет, что этот запрос или шаг полностью выполнен.  

_План выполнения_  
1) Множество способов выполнить запрос  
2) Нужно выбрать лучший  
3) «Стоимость» запроса  
  • количество страниц в таблице или в индексе  
  • кардинальность индекса  
  • длина строк и ключей  
  • распределение ключей в индексе

**Денормализация** - намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из
базы за счет добавления избыточных данных.  
Когда:  
• Большое количество соединений таблиц  
• Большое количество расчетов  
При денормализации данных вырастет количество записей, но уменьшится количество чтений.  

_Подходы при денормализации_  
• Дублирование.  
  + Избавляемся от JOIN’ов  
  - Обновлять данные в нескольких таблицах  
• Предварительная подготовка.  
  + Не тратим время на расчеты во время запроса  
  - Обновлять данные в одной и более таблицах  
• Группировка данных.  
  + Хранение нескольких значений в одном атрибуте  
  - Нет возможности осуществлять поиск

_Оптимизация DELETE_  
Очистка таблицы - **DELETE FROM film;** 
Для удаления всех записей из таблицы/таблиц есть отдельная команда - **TRUNCATE TABLE film;**  
Особенности:  
TRUNCATE на много быстрее, чем DELETE; нарушает изоляцию транзакций  

_Оптимизация GROUP BY и DISTINCT_  
```
-- До оптимизации  
SELECT actor.first_name, actor.last_name, COUNT(*)  
FROM film_actor  
INNER JOIN actor USING(actor_id)  
GROUP BY actor.first_name, actor.last_name;  

-- После оптимизации  
SELECT actor.first_name, actor.last_name, c.cnt  
FROM actor  
INNER JOIN (  
  SELECT actor_id, COUNT(*) AS cnt  
  FROM film_actor  
  GROUP BY actor_id  
) AS c USING(actor_id);  
```

_Оптимизация LIMIT со смещением_  
```
-- До оптимизации  
SELECT film_id, description  
FROM film  
ORDER BY title  
LIMIT 50, 5;

-- После оптимизации  
SELECT film.film_id, film.description   
FROM film  
INNER JOIN (  
  -- Использование индекса для поиска  
  SELECT film_id FROM film  
  ORDER BY title LIMIT 50, 5  
  ) AS lim USING(film_id);  
```

_Оптимизация COUNT(*)_  
• Получение кол-ва записей после выполнения запроса:  
`SELECT COUNT (*) FROM tags WHERE name LIKE 'Zombie%';`  
Если нужно ориентировочное количество записей в результате выполнения запроса, то можно получить их из плана выполнения:  
`EXPLAIN SELECT * FROM tags WHERE name LIKE 'Comedy%';`  

_**Оптимизация на уровне приложения**_  
1) **Кэш запросов** -  Обращение к БД дороже, чем обращение к файловой системе. Прочитав значение из БД,
сохраняем результат, например, в файловый кэш. При изменении записи необходимо инвалидировать кэш.
2) **Декомпозиция соединения**
```
-- Найти все новости с тегом sql одним запросом  
SELECT * FROM tag  
JOIN news_tag ON news_tag.id_tag = tag.id_tag  
JOIN news ON news_tag.id_news = news.id_news  
WHERE tag.name = 'sql';  

-- Найти все новости с тегом sql тремя запросами  
SELECT * FROM tag WHERE tag = 'sql';  
SELECT * FROM news_tag WHERE id_tag = 1234;  
SELECT * FROM news WHERE id_news IN (123,456,567,9098,8904);  
```  
Соединение в приложении может оказаться эффективнее в следующих случаях:  
• Организован кэш и вы повторно используете ранее запрошенные данные  
• Данные распределены по нескольким серверам  
• Вместо соединения с большой таблицей используется список IN()  

3) **Пакетная обработка**  
Пакетная обработка запросов может быть эффективнее из-за:  
• Возможности избежать задержки в сети при обращении к базе данных SQL;  
• Архитектуры базы данных;  
• Использования несколько баз данных (сегментирование/шардинг)

4) **Работа с транзакцией**  
Уменьшение времени блокировок за счет избавления от крупных и сложных запросов  
• Разбиение запроса на более мелкие;  
• Сокращайте время транзакции;  
• Направленное изменение записей с целью устранение возникновения deadlock;  
• Оптимистичные блокировки.

5) **Параллельная обработка**  
Попытка вставить 1000 строк в одну или несколько параллельных пакетов. Этот тест показывает, как большее количество одновременных пакетов фактически снижает производительность.  
После достижения неопределенного порогового значения большее число потоков уменьшит производительность, а не
повысит ее.  

### 23. План выполнения запроса.
План выполнения запроса - последовательность операций, необходимых для получения результата SQL-запроса.  

`SELECT FROM Продажа ORDER BY Номер_продавца `  
1) Сканирование кластерного индекса по первичному ключу таблицы Продажа.  
2) Сортировка результатов шага 1 по столбцу Номер_продавца.  
3) Возврат приложению результатов шага 2

_План выполнения запроса представляет собой:_  
• Последовательности, в которой происходит обращение к исходным таблицам.  
• Методы, используемые для извлечения данных из каждой таблицы.  
• Методы, используемые для вычислений, а также фильтрации, сортировки данных из каждой таблицы.  

_План выполнения MSSQL_  
• Actual Execution Plan (Предполагаемый план выполнения)  
• Estimated Execution Plan (Действительный план выполнения)  
• Statistics (Статистика активных запросов)  

### 24. OLAP и OLTP. Предназначения и отличия.  
**OLTP (OnLine Transaction Processing) и OLAP (OnLine Analytical Processing)** - это два различных типа систем обработки данных, предназначенных для различных целей. OLTP системы обрабатывают транзакции в реальном времени, обеспечивая ввод, обновление и извлечение данных, часто с небольшими объемами данных, но в больших количествах. OLAP системы, напротив, специализируются на анализе исторических данных, позволяя пользователям выполнять сложные запросы для получения сводных данных и формирования отчетов  

_Предпосылки появления OLAP_  
Проблемы реляционных СУБД:  
• Относительная сложность написания SQL запросов и их большое количество  
• Агрегированные выборки  
• Необходимость привлечения IT специалистов  

_Характеристики OLAP и OLTP_
1) **Характеристики OLTP системы**
   Назначение: Обработка транзакций в реальном времени, таких как ввод заказов, банковские операции, онлайн-продажи.  
- Часто различные БД для разных подразделений  
- Нормализованная схема, отсутствие дублирования информации
- Интенсивное изменение данных  
- Транзакционный режим работы  
- Транзакции затрагивают небольшой объем данных  
- Обработка текущих данных – мгновенный снимок  
- Очень много клиентов  
- Малое время отклика – несколько мс
  
2) **Характеристики OLAP системы**
   Назначение: Анализ исторических данных для принятия бизнес-решений, формирования отчетов, выявления тенденций и закономерностей.  
- Синхронизированная информация из различных БД с использованием общих классификаторов
- Ненормализованная схема БД с дубликатами
- Данные меняются редко, изменение происходит через пакетную загрузку
- Выполняются сложные нерегламентированные запросы над большим объемом данных с широким применением группировок и агрегатных функций.
- Анализ временных зависимостей
- Небольшое количество работающих пользователей – аналитики и менеджеры
- Большее время отклика (но все равно приемлемое) – несколько минут

![image](https://github.com/user-attachments/assets/c130b7d5-c6aa-418d-abac-773578f93bc0)  

### 25. NoSQL. Виды БД и их предназначения.
